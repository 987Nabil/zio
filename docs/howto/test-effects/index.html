<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>How to Test effects? · ZIO</title><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta name="generator" content="Docusaurus"/><meta name="description" content="## How zio-test was designed"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="How to Test effects? · ZIO"/><meta property="og:type" content="website"/><meta property="og:url" content="https://zio.dev/"/><meta property="og:description" content="## How zio-test was designed"/><meta name="twitter:card" content="summary"/><link rel="shortcut icon" href="/img/favicon.png"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script src="https://unpkg.com/vanilla-back-to-top@7.1.14/dist/vanilla-back-to-top.min.js"></script><script>
        document.addEventListener('DOMContentLoaded', function() {
          addBackToTop(
            {"zIndex":100,"cornerOffset":100}
          )
        });
        </script><script src="/js/scrollSpy.js"></script><link rel="stylesheet" href="/css/main.css"/><script src="/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/"><img class="logo" src="/img/navbar_brand.png" alt="ZIO"/><h2 class="headerTitleWithLogo">ZIO</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class=""><a href="/docs/overview/overview_index" target="_self">Overview</a></li><li class=""><a href="/docs/datatypes/" target="_self">Data Types</a></li><li class=""><a href="/docs/services/" target="_self">Services</a></li><li class=""><a href="/docs/usecases/usecases_index" target="_self">Use Cases</a></li><li class="siteNavGroupActive"><a href="/docs/howto/" target="_self">How to</a></li><li class=""><a href="/docs/resources/" target="_self">Resources</a></li><li class=""><a href="/docs/about/about_index" target="_self">About</a></li><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search" title="Search"/></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>How to</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">Overview<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/docs/howto/">Summary</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">How to<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/docs/howto/use-test-assertions">How to Use Test Assertions</a></li><li class="navListItem navListItemActive"><a class="navItem" href="/docs/howto/test-effects">How to Test effects?</a></li><li class="navListItem"><a class="navItem" href="/docs/howto/mock-services">How to Mock Services?</a></li><li class="navListItem"><a class="navItem" href="/docs/howto/handle-errors">How to Handle Errors?</a></li><li class="navListItem"><a class="navItem" href="/docs/howto/access-system-information">How to Access System Information?</a></li><li class="navListItem"><a class="navItem" href="/docs/howto/use-zio-macros">How to use ZIO Macros?</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">Interop<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/docs/howto/interop/with-cats-effect">How to Interop with Cats Effect?</a></li><li class="navListItem"><a class="navItem" href="/docs/howto/interop/with-future">How to Interop with Future?</a></li><li class="navListItem"><a class="navItem" href="/docs/howto/interop/with-java">How to Interop with Java?</a></li><li class="navListItem"><a class="navItem" href="/docs/howto/interop/with-javascript">How to Interop with JavaScript?</a></li><li class="navListItem"><a class="navItem" href="/docs/howto/interop/with-monix">How to Interop with Monix?</a></li><li class="navListItem"><a class="navItem" href="/docs/howto/interop/with-scalaz-7x">How to Interop with Scalaz 7.x?</a></li><li class="navListItem"><a class="navItem" href="/docs/howto/interop/with-reactive-streams">How to Interop with Reactive Streams?</a></li><li class="navListItem"><a class="navItem" href="/docs/howto/interop/with-twitter">How to Interop with Twitter?</a></li><li class="navListItem"><a class="navItem" href="/docs/howto/interop/with-guava">How to Interop with Guava?</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">Migrate<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/docs/howto/migrate/from-monix">How to Migrate from Monix to ZIO?</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer docsContainer"><div class="wrapper"><div class="post"><header class="postHeader"><a class="edit-page-link button" href="https://github.com/zio/zio/edit/master/docs/howto/test_effects.md" target="_blank" rel="noreferrer noopener">Edit</a><h1 id="__docusaurus" class="postHeaderTitle">How to Test effects?</h1></header><article><div><span><h2><a class="anchor" aria-hidden="true" id="how-zio-test-was-designed"></a><a href="#how-zio-test-was-designed" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>How zio-test was designed</h2>
<p><code>zio-test</code> is designed around the idea of making tests first-class objects. What it means is that tests (and other accompanying concepts like assertions) become ordinary values that can be passed around, transformed and composed together. This approach allows for greater flexibility comparing to some other testing frameworks where tests and additional logic around tests had to be put into callbacks so that framework could make use of them. This approach also fits better with other <code>ZIO</code> concepts like <code>ZManaged</code> which can only be used within a scoped block of code. This also created a mismatch between <code>BeforeAll</code>, <code>AfterAll</code> callback-like methods when there were resources that should be opened and closed during test suite execution.
Another thing worth pointing out is that tests being values, are also effects. Implications of this design are far reaching. First of all well known problem of testing asynchronous value is gone. Whereas in other frameworks you have to somehow &quot;run&quot; your effects
and at best wrap them in <code>scala.util.Future</code> because blocking would eliminate running on ScalaJS, <code>zio-test</code> expects you to create <code>ZIO</code> objects. There is no need for indirect transformations from one wrapping object to another. Second, because our tests are ordinary <code>ZIO</code> values we don't need to turn to testing framework for things like retries, timeouts and resource management. We can solve all those problems with full richness of functions that <code>ZIO</code> exposes.</p>
<h2><a class="anchor" aria-hidden="true" id="constructing-tests"></a><a href="#constructing-tests" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Constructing tests</h2>
<p>All below code assumes that you have imported <code>zio.test._</code></p>
<p>The backbone of <code>zio-test</code> is the <code>Spec[L, T]</code> class. Every spec is labeled with <code>L</code> and can be a suite which contains other specs or a test of type <code>T</code>.</p>
<p>The most common and easy way to create suites is to use <code>suite</code> function. For testing of pure functions there is <code>test</code> function and for effectful testing there is <code>testM</code></p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> zio.test._
<span class="hljs-keyword">import</span> zio.test.environment.<span class="hljs-type">Live</span>
<span class="hljs-keyword">import</span> zio.clock.nanoTime
<span class="hljs-keyword">import</span> <span class="hljs-type">Assertion</span>.isGreaterThan

<span class="hljs-keyword">val</span> clockSuite = suite(<span class="hljs-string">"clock"</span>) (
  testM(<span class="hljs-string">"time is non-zero"</span>) {
    assertM(<span class="hljs-type">Live</span>.live(nanoTime))(isGreaterThan(<span class="hljs-number">0</span>L))
  }
)
<span class="hljs-comment">// clockSuite: Spec[Live, TestFailure[Nothing], TestSuccess] = Spec(</span>
<span class="hljs-comment">//   caseValue = SuiteCase(</span>
<span class="hljs-comment">//     label = "clock",</span>
<span class="hljs-comment">//     specs = zio.ZManaged$$anon$2@217b4027,</span>
<span class="hljs-comment">//     exec = None</span>
<span class="hljs-comment">//   )</span>
<span class="hljs-comment">// )</span>
</code></pre>
<p>As you can see the whole suite was assigned to <code>clockSuite</code> val. As it was said suites can contain other suites so we can aggregate them as much as needed. Example, we can have multiple suites that test external HTTP apis and one big suite that will aggregate them all.</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> zio.test._
<span class="hljs-keyword">import</span> <span class="hljs-type">Assertion</span>._

<span class="hljs-keyword">val</span> paymentProviderABCSuite  = suite(<span class="hljs-string">"ABC payment provider tests"</span>) {test(<span class="hljs-string">"Your test"</span>)(assert(<span class="hljs-string">"Your value"</span>)(<span class="hljs-type">Assertion</span>.isNonEmptyString))}
<span class="hljs-comment">// paymentProviderABCSuite: Spec[Any, TestFailure[Nothing], TestSuccess] = Spec(</span>
<span class="hljs-comment">//   caseValue = SuiteCase(</span>
<span class="hljs-comment">//     label = "ABC payment provider tests",</span>
<span class="hljs-comment">//     specs = zio.ZManaged$$anon$2@7ab9da29,</span>
<span class="hljs-comment">//     exec = None</span>
<span class="hljs-comment">//   )</span>
<span class="hljs-comment">// )</span>
<span class="hljs-keyword">val</span> paymentProviderXYZSuite  = suite(<span class="hljs-string">"XYZ payment provider tests"</span>) {test(<span class="hljs-string">"Your other test"</span>)(assert(<span class="hljs-string">"Your other value"</span>)(<span class="hljs-type">Assertion</span>.isNonEmptyString))}
<span class="hljs-comment">// paymentProviderXYZSuite: Spec[Any, TestFailure[Nothing], TestSuccess] = Spec(</span>
<span class="hljs-comment">//   caseValue = SuiteCase(</span>
<span class="hljs-comment">//     label = "XYZ payment provider tests",</span>
<span class="hljs-comment">//     specs = zio.ZManaged$$anon$2@1d670bc2,</span>
<span class="hljs-comment">//     exec = None</span>
<span class="hljs-comment">//   )</span>
<span class="hljs-comment">// )</span>
<span class="hljs-keyword">val</span> allPaymentProvidersTests = suite(<span class="hljs-string">"All payment providers tests"</span>)(paymentProviderABCSuite, paymentProviderXYZSuite)
<span class="hljs-comment">// allPaymentProvidersTests: Spec[Any, TestFailure[Nothing], TestSuccess] = Spec(</span>
<span class="hljs-comment">//   caseValue = SuiteCase(</span>
<span class="hljs-comment">//     label = "All payment providers tests",</span>
<span class="hljs-comment">//     specs = zio.ZManaged$$anon$2@7eff1298,</span>
<span class="hljs-comment">//     exec = None</span>
<span class="hljs-comment">//   )</span>
<span class="hljs-comment">// )</span>
</code></pre>
<p>Real tests that run some logic and return testing result are created mostly with <code>testM</code> function. It expects two arguments, first one that will be the label of test
which will be used for visual reporting back to the user and an assertion of type
<code>ZIO[R, E, TestResult]</code>. This means writing test in <code>zio-test</code> mostly gets down to creating a <code>ZIO</code> object that
will produce <code>TestResult</code>. There is another variant of function for creating test that are pure called simply <code>test</code>.
It expects a thunk of code that will just return a <code>TestResult</code> without packing it into <code>ZIO</code>.</p>
<h3><a class="anchor" aria-hidden="true" id="assertions---creating-testresults"></a><a href="#assertions---creating-testresults" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Assertions - creating TestResults</h3>
<p>As it was already mentioned tests should return <code>TestResult</code>. The most common way to produce a <code>TestResult</code>
is to resort to <code>assert</code> or its effectful counterpart <code>assertM</code>. Both of them accept a value of type <code>A</code> (effectful version wrapped in a <code>ZIO</code>) and an <code>Assertion[A]</code>.
To create <code>Assertion[A]</code> object one can use functions defined under <code>zio.test.Assertion</code>. There are already a number
of useful assertions predefined like <code>equalTo</code>, <code>isFalse</code>, <code>isTrue</code>, <code>contains</code>, <code>throws</code> and more.
What is really useful in assertions is that they behave like boolean values and can be composed with operators
known from operating on boolean values like and (<code>&amp;&amp;</code>), or (<code>||</code>), negation (<code>negate</code>).</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> zio.test.<span class="hljs-type">Assertion</span>

<span class="hljs-keyword">val</span> assertionForString: <span class="hljs-type">Assertion</span>[<span class="hljs-type">String</span>] = <span class="hljs-type">Assertion</span>.containsString(<span class="hljs-string">"Foo"</span>) &amp;&amp; <span class="hljs-type">Assertion</span>.endsWithString(<span class="hljs-string">"Bar"</span>)
<span class="hljs-comment">// assertionForString: Assertion[String] = (containsString(Foo) &amp;&amp; endsWithString(Bar))</span>
</code></pre>
<p>What's more, assertions also compose with each other allowing for doing rich diffs not only simple value to value comparison.</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> zio.test.<span class="hljs-type">Assertion</span>.{isRight, isSome,equalTo, hasField}

test(<span class="hljs-string">"Check assertions"</span>) {
  assert(<span class="hljs-type">Right</span>(<span class="hljs-type">Some</span>(<span class="hljs-number">2</span>)))(isRight(isSome(equalTo(<span class="hljs-number">2</span>))))
}
<span class="hljs-comment">// res0: ZSpec[Any, Nothing] = Spec(</span>
<span class="hljs-comment">//   caseValue = TestCase(</span>
<span class="hljs-comment">//     label = "Check assertions",</span>
<span class="hljs-comment">//     test = &lt;function1&gt;,</span>
<span class="hljs-comment">//     annotations = Map(zio.test.TestAnnotation@fa40ba79 -&gt; List(SourceLocation(test_effects.md,60)))</span>
<span class="hljs-comment">//   )</span>
<span class="hljs-comment">// )</span>
</code></pre>
<p>Here we're checking deeply nested values inside an <code>Either</code> and <code>Option</code>. Because <code>Assertion</code>s compose this is not a problem
all layers are being peeled off tested for condition until final value is reached.
Here the expression <code>Right(Some(2))</code> is of type <code>Either[Any, Option[Int]]</code>and our assertion <code>isRight(isSome(equalTo(2)))</code>
is of type <code>Assertion[Either[Any, Option[Int]]]</code></p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> zio.test._
<span class="hljs-keyword">import</span> zio.test.<span class="hljs-type">Assertion</span>.{isRight, isSome,equalTo, isGreaterThanEqualTo, not, hasField}

<span class="hljs-keyword">final</span> <span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Address</span>(<span class="hljs-params">country:<span class="hljs-type">String</span>, city:<span class="hljs-type">String</span></span>)</span>
<span class="hljs-keyword">final</span> <span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span>(<span class="hljs-params">name:<span class="hljs-type">String</span>, age:<span class="hljs-type">Int</span>, address: <span class="hljs-type">Address</span></span>)</span>

test(<span class="hljs-string">"Rich checking"</span>) {
  assert(
    <span class="hljs-type">User</span>(<span class="hljs-string">"Jonny"</span>, <span class="hljs-number">26</span>, <span class="hljs-type">Address</span>(<span class="hljs-string">"Denmark"</span>, <span class="hljs-string">"Copenhagen"</span>))
  )(
    hasField(<span class="hljs-string">"age"</span>, (u:<span class="hljs-type">User</span>) =&gt; u.age, isGreaterThanEqualTo(<span class="hljs-number">18</span>)) &amp;&amp;
    hasField(<span class="hljs-string">"country"</span>, (u:<span class="hljs-type">User</span>) =&gt; u.address.country, not(equalTo(<span class="hljs-string">"USA"</span>)))
  )
}
<span class="hljs-comment">// res2: ZSpec[Any, Nothing] = Spec(</span>
<span class="hljs-comment">//   caseValue = TestCase(</span>
<span class="hljs-comment">//     label = "Rich checking",</span>
<span class="hljs-comment">//     test = &lt;function1&gt;,</span>
<span class="hljs-comment">//     annotations = Map(zio.test.TestAnnotation@fa40ba79 -&gt; List(SourceLocation(test_effects.md,83)))</span>
<span class="hljs-comment">//   )</span>
<span class="hljs-comment">// )</span>
</code></pre>
<p>There is also an easy way to test object's data for certain assertions with <code>hasField</code> which accepts besides a name, a mapping function from object to its tested property and <code>Assertion</code> object which will validate this property. Here our test checks if a person has at least 18 years and is not from USA. What is nice about those tests is that, test reporters will tell you exactly which assertion was broken. Let's say we would change <code>isGreaterThanEqualTo(18)</code> to <code>isGreaterThanEqualTo(40)</code> which will fail. Printout
on console will be a nice detailed text explaining what exactly went wrong:</p>
<pre><code class="hljs css language-bash">[info]       User(Jonny,26,Address(Denmark,Copenhagen)) did not satisfy (hasField(<span class="hljs-string">"age"</span>, _.age, isGreaterThanEqualTo(45)) &amp;&amp; hasField(<span class="hljs-string">"country"</span>, _.country, not(equalTo(USA))))
[info]       26 did not satisfy isGreaterThanEqualTo(45)
</code></pre>
<p>Having this all in mind probably the most common and also most readable way of structuring tests is to pass
a for-comprehension to <code>testM</code> function and yield a call to <code>assert</code> function.</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> zio._
<span class="hljs-keyword">import</span> zio.test._
<span class="hljs-keyword">import</span> <span class="hljs-type">Assertion</span>._

testM(<span class="hljs-string">"Semaphore should expose available number of permits"</span>) {
  <span class="hljs-keyword">for</span> {
    s         &lt;- <span class="hljs-type">Semaphore</span>.make(<span class="hljs-number">1</span>L)
    permits   &lt;- s.available
  } <span class="hljs-keyword">yield</span> assert(permits)(equalTo(<span class="hljs-number">1</span>L))
}
<span class="hljs-comment">// res3: ZSpec[Any, Nothing] = Spec(</span>
<span class="hljs-comment">//   caseValue = TestCase(</span>
<span class="hljs-comment">//     label = "Semaphore should expose available number of permits",</span>
<span class="hljs-comment">//     test = &lt;function1&gt;,</span>
<span class="hljs-comment">//     annotations = Map(zio.test.TestAnnotation@fa40ba79 -&gt; List(SourceLocation(test_effects.md,105)))</span>
<span class="hljs-comment">//   )</span>
<span class="hljs-comment">// )</span>
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="running-tests"></a><a href="#running-tests" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Running tests</h3>
<p>When all of our tests are constructed, we need to have a way to actually execute them. Your first stop is the <code>zio.test.DefaultRunnableSpec</code> which accepts a single suite that will be executed. A single suite might seem to be limiting but as it was already said suites can hold any number of other suites. You may structure your tests like this:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> zio.test._
<span class="hljs-keyword">import</span> zio.clock.nanoTime
<span class="hljs-keyword">import</span> <span class="hljs-type">Assertion</span>._

<span class="hljs-keyword">val</span> suite1 = suite(<span class="hljs-string">"suite1"</span>) (
  testM(<span class="hljs-string">"s1.t1"</span>) {assertM(nanoTime)(isGreaterThanEqualTo(<span class="hljs-number">0</span>L))},
  testM(<span class="hljs-string">"s1.t2"</span>) {assertM(nanoTime)(isGreaterThanEqualTo(<span class="hljs-number">0</span>L))}
)
<span class="hljs-comment">// suite1: Spec[clock.package.Clock, TestFailure[Nothing], TestSuccess] = Spec(</span>
<span class="hljs-comment">//   caseValue = SuiteCase(</span>
<span class="hljs-comment">//     label = "suite1",</span>
<span class="hljs-comment">//     specs = zio.ZManaged$$anon$2@143ed1f1,</span>
<span class="hljs-comment">//     exec = None</span>
<span class="hljs-comment">//   )</span>
<span class="hljs-comment">// )</span>
<span class="hljs-keyword">val</span> suite2 = suite(<span class="hljs-string">"suite2"</span>) (
  testM(<span class="hljs-string">"s2.t1"</span>) {assertM(nanoTime)(isGreaterThanEqualTo(<span class="hljs-number">0</span>L))},
  testM(<span class="hljs-string">"s2.t2"</span>) {assertM(nanoTime)(isGreaterThanEqualTo(<span class="hljs-number">0</span>L))},
  testM(<span class="hljs-string">"s2.t3"</span>) {assertM(nanoTime)(isGreaterThanEqualTo(<span class="hljs-number">0</span>L))}
)
<span class="hljs-comment">// suite2: Spec[clock.package.Clock, TestFailure[Nothing], TestSuccess] = Spec(</span>
<span class="hljs-comment">//   caseValue = SuiteCase(</span>
<span class="hljs-comment">//     label = "suite2",</span>
<span class="hljs-comment">//     specs = zio.ZManaged$$anon$2@12536a3c,</span>
<span class="hljs-comment">//     exec = None</span>
<span class="hljs-comment">//   )</span>
<span class="hljs-comment">// )</span>
<span class="hljs-keyword">val</span> suite3 = suite(<span class="hljs-string">"suite3"</span>) (
  testM(<span class="hljs-string">"s3.t1"</span>) {assertM(nanoTime)(isGreaterThanEqualTo(<span class="hljs-number">0</span>L))}
)
<span class="hljs-comment">// suite3: Spec[clock.package.Clock, TestFailure[Nothing], TestSuccess] = Spec(</span>
<span class="hljs-comment">//   caseValue = SuiteCase(</span>
<span class="hljs-comment">//     label = "suite3",</span>
<span class="hljs-comment">//     specs = zio.ZManaged$$anon$2@67a0a1a1,</span>
<span class="hljs-comment">//     exec = None</span>
<span class="hljs-comment">//   )</span>
<span class="hljs-comment">// )</span>

<span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">AllSuites</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">DefaultRunnableSpec</span> </span>{
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">spec</span> </span>= suite(<span class="hljs-string">"All tests"</span>)(suite1, suite2, suite3)
}
</code></pre>
<p><code>DefaultRunnableSpec</code> is very similar in its logic of operations to <code>zio.App</code>. Instead of providing one <code>ZIO</code> application
at the end of the world we provide a suite that can be a tree of other suites and tests. Another resemblance is that <code>DefaultRunnableSpec</code> provides an Environment. Here it is an instance of <code>TestEnvironment</code> which helps us with controlling our systems infrastructure. More info on using test environment can be found in sections below.
Just like with <code>zio.App</code> where at the very end an instance of <code>ZIO[R,E,A]</code> is expected where <code>R</code> can be at maximum of type <code>Environment</code> in <code>DefaultRunnableSpec</code> <code>R</code> cannot be more than <code>TestEnvironment</code>. So just like in normal application if our
<code>R</code> is composed of some other modules we need to provide them first before test can be executed. How can we provide our dependencies?
Here again the design of <code>zio-test</code> shines. Since our tests are ordinary values we can just transform them with a call to <code>mapTest</code>.
It accepts a lambda of type <code>ZIO[R with TestSystem, TestFailure[Throwable], TestSuccess[Unit] ] =&gt; T1</code>. Without getting into too much details about types we can see that our lambda argument is a test instance (<code>ZIO</code>) that expects an environment of type <code>R with TestSystem</code>. This is no different from normal usage of ZIO in <code>zio.App</code>. We can use the same <code>provide</code>, <code>provideSome</code> methods to provide modules which <code>DefaultRunnableSpec</code> cannot provide itself as those are users modules. When all dependencies are provided we can run our tests in two ways. If we added <code>zio-test-sbt</code> to our dependencies and <code>zio.test.sbt.TestFramework</code> to SBT's <code>testFrameworks</code> our tests should be automatically picked up by SBT on invocation of <code>test</code>. However if we're not using SBT or have some other special needs <code>DefaultRunnableSpec</code> has a <code>main</code> method which can be invoked directly or with SBTs <code>test:run</code>.</p>
<pre><code class="hljs css language-sbt">libraryDependencies ++= Seq(
  <span class="hljs-string">"dev.zio"</span> %% <span class="hljs-string">"zio-test"</span>     % zioVersion % <span class="hljs-string">"test"</span>,
  <span class="hljs-string">"dev.zio"</span> %% <span class="hljs-string">"zio-test-sbt"</span> % zioVersion % <span class="hljs-string">"test"</span>
),
testFrameworks += <span class="hljs-keyword">new</span> <span class="hljs-type">TestFramework</span>(<span class="hljs-string">"zio.test.sbt.ZTestFramework"</span>)
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="using-test-environment"></a><a href="#using-test-environment" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Using Test Environment</h2>
<p>What we expect from tests (at least those that we consider unit tests) is to be stable i.e. consecutive runs should yield the same results and take
more or less the same amount of time. Biggest source of complexity during testing comes from external services which we cannot control like external
payment APIs, object storages, http APIs etc. It is normal to hide these kind of services behind an interface and provide test instances to regain
control and determinism. However there is another source of complexity that comes from the local infrastructure that is also hard to control without building prior abstractions. Things like stdin/stdout, clocks, random generators, schedulers can make writing tests hard or even impossible. Fortunately ZIO abstracted most of it in its runtime under <code>Environment</code> type. Thanks to this design <code>zio-test</code> could easily provide its own implementation named <code>TestEnvironment</code> which gives you test implementations of mentioned infrastructure. In most of the cases when you'll be using <code>ZIO</code>s <code>testM</code> test implementations are already created and should be controlled by exposed functions on companion object. If for some reason you would like to provide custom environment or are using other testing framework but still want to use test environment there are <code>make</code> functions on companion objects of test modules where you can construct your own.</p>
<p>It is easy to accidentally use different test instances at the same time.</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> zio.test._
<span class="hljs-keyword">import</span> zio.test.environment.<span class="hljs-type">TestClock</span>
<span class="hljs-keyword">import</span> <span class="hljs-type">Assertion</span>._
<span class="hljs-keyword">import</span> zio.duration._

testM(<span class="hljs-string">"`acquire` doesn't leak permits upon cancellation"</span>) {
  <span class="hljs-keyword">for</span> {
      testClock &lt;- <span class="hljs-type">TestClock</span>.makeTest(<span class="hljs-type">TestClock</span>.<span class="hljs-type">DefaultData</span>)
      s         &lt;- <span class="hljs-type">Semaphore</span>.make(<span class="hljs-number">1</span>L)
      sf        &lt;- s.acquireN(<span class="hljs-number">2</span>).timeout(<span class="hljs-number">1.</span>millisecond).either.fork
      _         &lt;- testClock.adjust(<span class="hljs-number">1.</span>second)
      _         &lt;- sf.join
      _         &lt;- s.release
      permits   &lt;- s.available
  } <span class="hljs-keyword">yield</span> assert(permits, equalTo(<span class="hljs-number">2</span>L))
}
</code></pre>
<p>Above code doesn't work. We created a new <code>TestClock</code> instance and are correctly adjusting its time. What might be surprising is that call to <code>timeout</code> will use the <code>TestClock</code> provided by the <code>TestEnvironment</code> not our <code>testClock</code> instance. It easy to know why when you look at the signature of <code>timeout</code>:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> zio.duration.<span class="hljs-type">Duration</span>
<span class="hljs-keyword">import</span> zio.clock.<span class="hljs-type">Clock</span>

<span class="hljs-keyword">sealed</span> <span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">ZIO</span>[-<span class="hljs-type">R</span>, +<span class="hljs-type">E</span>, +<span class="hljs-type">A</span>] <span class="hljs-keyword">extends</span> <span class="hljs-title">Serializable</span> </span>{ self =&gt;
    <span class="hljs-comment">/* All other method declarations in this trait ignored to avoid clutter */</span>

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">timeout</span></span>(d: <span class="hljs-type">Duration</span>): <span class="hljs-type">ZIO</span>[<span class="hljs-type">R</span> <span class="hljs-keyword">with</span> <span class="hljs-type">Clock</span>, <span class="hljs-type">E</span>, <span class="hljs-type">Option</span>[<span class="hljs-type">A</span>]]
}
</code></pre>
<p>The returned type is <code>ZIO[R with Clock, E, Option[A]]</code> where our environment is &quot;some R plus a Clock&quot;.
Before running this <code>Clock</code> has to be provided and the framework provides the Clock from the <code>TestEnvironment</code> not our instance variable as it is not aware that we created it.</p>
<p>If you need to provide real implementations instead of the test instances to some part of your tests there is a <code>live</code> method which will transform your <code>ZIO[R, E, A]</code> to <code>ZIO[Live[R], E, A]</code>. Going from <code>R</code> to <code>Live[R]</code> instructs the framework that we really want to be provided with live implementations.</p>
<h3><a class="anchor" aria-hidden="true" id="testing-random"></a><a href="#testing-random" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Testing Random</h3>
<p>When working with randomness testing might be hard because the inputs to the tested function change on every invocation so our code behave in a indeterministic way. Precisely because of this reason <code>ZIO</code> exposes <code>TestRandom</code> module which allows for fully deterministic testing of code
that deals with Randomness.
<code>TestRandom</code> can operate in two modes based on needed use case. In first mode it is a purely functional pseudo-random number generator. During generation on random values like when calling <code>nextInt</code> no internal state is being mutated. It is expected to chain such operations with combinators like <code>flatMap</code>. To preserve the same values generated between invocation of tests <code>setSeed</code> method can be used. It is guaranteed to return the same sequence of values for any given seed.</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> zio.test.assert
<span class="hljs-keyword">import</span> zio.test.environment.<span class="hljs-type">TestRandom</span>
<span class="hljs-keyword">import</span> zio.test.<span class="hljs-type">Assertion</span>.equalTo

testM(<span class="hljs-string">"Use setSeed to generate stable values"</span>) {
  <span class="hljs-keyword">for</span> {
    _  &lt;- <span class="hljs-type">TestRandom</span>.setSeed(<span class="hljs-number">27</span>)
    r1 &lt;- random.nextLong
    r2 &lt;- random.nextLong
    r3 &lt;- random.nextLong
  } <span class="hljs-keyword">yield</span>
    assert(<span class="hljs-type">List</span>(r1,r2,r3))(equalTo(<span class="hljs-type">List</span>[<span class="hljs-type">Long</span>](
      <span class="hljs-number">-4947896108136290151</span>L,
      <span class="hljs-number">-5264020926839611059</span>L,
      <span class="hljs-number">-9135922664019402287</span>L
    )))
}
<span class="hljs-comment">// res4: ZSpec[TestRandom with random.package.Random, Nothing] = Spec(</span>
<span class="hljs-comment">//   caseValue = TestCase(</span>
<span class="hljs-comment">//     label = "Use setSeed to generate stable values",</span>
<span class="hljs-comment">//     test = &lt;function1&gt;,</span>
<span class="hljs-comment">//     annotations = Map(zio.test.TestAnnotation@fa40ba79 -&gt; List(SourceLocation(test_effects.md,176)))</span>
<span class="hljs-comment">//   )</span>
<span class="hljs-comment">// )</span>
</code></pre>
<p>In second mode <code>TestRandom</code> maintains an internal buffer of values that can be &quot;fed&quot; upfront with methods such as <code>feedInts</code>. When random values are being generated first values from that buffer are being used.</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> zio.test.environment.<span class="hljs-type">TestRandom</span>
testM(<span class="hljs-string">"One can provide its own list of ints"</span>) {
  <span class="hljs-keyword">for</span> {
    _  &lt;- <span class="hljs-type">TestRandom</span>.feedInts(<span class="hljs-number">1</span>, <span class="hljs-number">9</span>, <span class="hljs-number">2</span>, <span class="hljs-number">8</span>, <span class="hljs-number">3</span>, <span class="hljs-number">7</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">5</span>)
    r1 &lt;- random.nextInt
    r2 &lt;- random.nextInt
    r3 &lt;- random.nextInt
    r4 &lt;- random.nextInt
    r5 &lt;- random.nextInt
    r6 &lt;- random.nextInt
    r7 &lt;- random.nextInt
    r8 &lt;- random.nextInt
    r9 &lt;- random.nextInt
  } <span class="hljs-keyword">yield</span> assert(
    <span class="hljs-type">List</span>(<span class="hljs-number">1</span>, <span class="hljs-number">9</span>, <span class="hljs-number">2</span>, <span class="hljs-number">8</span>, <span class="hljs-number">3</span>, <span class="hljs-number">7</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">5</span>)
  )(equalTo(<span class="hljs-type">List</span>(r1, r2, r3, r4, r5, r6, r7, r8, r9)))
}
<span class="hljs-comment">// res5: ZSpec[TestRandom with random.package.Random, Nothing] = Spec(</span>
<span class="hljs-comment">//   caseValue = TestCase(</span>
<span class="hljs-comment">//     label = "One can provide its own list of ints",</span>
<span class="hljs-comment">//     test = &lt;function1&gt;,</span>
<span class="hljs-comment">//     annotations = Map(zio.test.TestAnnotation@fa40ba79 -&gt; List(SourceLocation(test_effects.md,197)))</span>
<span class="hljs-comment">//   )</span>
<span class="hljs-comment">// )</span>
</code></pre>
<p>When we run out of values in buffer <code>TestRandom</code> it falls back to first mode. If we want to we can also clear internal buffers by calling method
like <code>clearInts</code>.</p>
<h3><a class="anchor" aria-hidden="true" id="testing-clock"></a><a href="#testing-clock" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Testing Clock</h3>
<p>In most cases you want unit tests to be as fast as possible. Waiting for real time to pass by is a real killer for  this. ZIO exposes a <code>TestClock</code> in <code>TestEnvironment</code> that can control time so we can deterministically and efficiently  test effects involving the passage of time without actually having to wait for the full amount of time to pass. Calls to <code>sleep</code> and methods derived from it will semantically block until the clock time is set/adjusted to on or after the time the effect is scheduled to run.</p>
<h4><a class="anchor" aria-hidden="true" id="clock-time"></a><a href="#clock-time" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Clock Time</h4>
<p>Clock time is just like a clock on the wall, except that in our <code>TestClock</code>, the clock is broken Instead of moving by itself, the clock time only changes when adjusted or set by the user, using the <code>adjust</code> and <code>setTime</code> methods. The clock time never changes by itself. When the clock is adjusted, any effects scheduled to run on or before the new clock time will automatically be run, in order.</p>
<h4><a class="anchor" aria-hidden="true" id="examples"></a><a href="#examples" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Examples</h4>
<p><strong>Example 1</strong></p>
<p>Thanks to the call to <code>TestClock.adjust(1.minute)</code> we moved the time instantly 1 minute.</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> java.util.concurrent.<span class="hljs-type">TimeUnit</span>
<span class="hljs-keyword">import</span> zio.clock.currentTime
<span class="hljs-keyword">import</span> zio.duration._
<span class="hljs-keyword">import</span> zio.test.<span class="hljs-type">Assertion</span>.isGreaterThanEqualTo
<span class="hljs-keyword">import</span> zio.test._
<span class="hljs-keyword">import</span> zio.test.environment.<span class="hljs-type">TestClock</span>

testM(<span class="hljs-string">"One can move time very fast"</span>) {
  <span class="hljs-keyword">for</span> {
    startTime &lt;- currentTime(<span class="hljs-type">TimeUnit</span>.<span class="hljs-type">SECONDS</span>)
    _         &lt;- <span class="hljs-type">TestClock</span>.adjust(<span class="hljs-number">1.</span>minute)
    endTime   &lt;- currentTime(<span class="hljs-type">TimeUnit</span>.<span class="hljs-type">SECONDS</span>)
  } <span class="hljs-keyword">yield</span> assert(endTime - startTime)(isGreaterThanEqualTo(<span class="hljs-number">60</span>L))
}
<span class="hljs-comment">// res6: ZSpec[TestClock with Clock, Nothing] = Spec(</span>
<span class="hljs-comment">//   caseValue = TestCase(</span>
<span class="hljs-comment">//     label = "One can move time very fast",</span>
<span class="hljs-comment">//     test = &lt;function1&gt;,</span>
<span class="hljs-comment">//     annotations = Map(zio.test.TestAnnotation@fa40ba79 -&gt; List(SourceLocation(test_effects.md,236)))</span>
<span class="hljs-comment">//   )</span>
<span class="hljs-comment">// )</span>
</code></pre>
<p><strong>Example 2</strong></p>
<p><code>TestClock</code> affects also all code running asynchronously that is scheduled to run after a certain time.</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> zio.duration._
<span class="hljs-keyword">import</span> zio.test.<span class="hljs-type">Assertion</span>.equalTo
<span class="hljs-keyword">import</span> zio.test._
<span class="hljs-keyword">import</span> zio.test.environment.<span class="hljs-type">TestClock</span>

testM(<span class="hljs-string">"One can control time as he see fit"</span>) {
  <span class="hljs-keyword">for</span> {
    promise &lt;- <span class="hljs-type">Promise</span>.make[<span class="hljs-type">Unit</span>, <span class="hljs-type">Int</span>]
    _       &lt;- (<span class="hljs-type">ZIO</span>.sleep(<span class="hljs-number">10.</span>seconds) *&gt; promise.succeed(<span class="hljs-number">1</span>)).fork
    _       &lt;- <span class="hljs-type">TestClock</span>.adjust(<span class="hljs-number">10.</span>seconds)
    readRef &lt;- promise.await
  } <span class="hljs-keyword">yield</span> assert(<span class="hljs-number">1</span>)(equalTo(readRef))
}
<span class="hljs-comment">// res7: ZSpec[Clock with TestClock, Unit] = Spec(</span>
<span class="hljs-comment">//   caseValue = TestCase(</span>
<span class="hljs-comment">//     label = "One can control time as he see fit",</span>
<span class="hljs-comment">//     test = &lt;function1&gt;,</span>
<span class="hljs-comment">//     annotations = Map(zio.test.TestAnnotation@fa40ba79 -&gt; List(SourceLocation(test_effects.md,260)))</span>
<span class="hljs-comment">//   )</span>
<span class="hljs-comment">// )</span>
</code></pre>
<p>The above code creates a write once cell that will be set to &quot;1&quot; after 10 seconds asynchronously from a different thread thanks to call to <code>fork</code>. At the end we wait on the promise until it is set. With call to <code>TestClock.adjust(10.seconds)</code> we simulate passing of 10 seconds of time. Because of it we don't need to wait for the real 10 seconds to pass and thus our unit test can run faster This is a pattern that will very often be used when <code>sleep</code> and <code>TestClock</code> are being used for testing of effects that are based on time. The fiber that needs to sleep will be forked and <code>TestClock</code> will used to adjust the time so that all expected effects are run in the forked fiber.</p>
<p><strong>Example 3</strong></p>
<p>A more complex example leveraging layers and multiple services is shown below.</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> zio.clock.<span class="hljs-type">Clock</span>
<span class="hljs-keyword">import</span> zio.duration._
<span class="hljs-keyword">import</span> zio.test.<span class="hljs-type">Assertion</span>._
<span class="hljs-keyword">import</span> zio.test._
<span class="hljs-keyword">import</span> zio.test.environment.{ <span class="hljs-type">TestClock</span>, <span class="hljs-type">TestEnvironment</span> }
<span class="hljs-keyword">import</span> zio._

<span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">SchedulingService</span> </span>{
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">schedule</span></span>(promise: <span class="hljs-type">Promise</span>[<span class="hljs-type">Unit</span>, <span class="hljs-type">Int</span>]): <span class="hljs-type">ZIO</span>[<span class="hljs-type">Any</span>, <span class="hljs-type">Exception</span>, <span class="hljs-type">Boolean</span>]
}

<span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">LoggingService</span> </span>{
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">log</span></span>(msg: <span class="hljs-type">String</span>): <span class="hljs-type">ZIO</span>[<span class="hljs-type">Any</span>, <span class="hljs-type">Exception</span>, <span class="hljs-type">Unit</span>]
}

<span class="hljs-keyword">val</span> schedulingLayer: <span class="hljs-type">ZLayer</span>[<span class="hljs-type">Clock</span> <span class="hljs-keyword">with</span> <span class="hljs-type">Has</span>[<span class="hljs-type">LoggingService</span>], <span class="hljs-type">Nothing</span>, <span class="hljs-type">Has</span>[<span class="hljs-type">SchedulingService</span>]] =
  <span class="hljs-type">ZLayer</span>.fromFunction { env =&gt;
    <span class="hljs-keyword">new</span> <span class="hljs-type">SchedulingService</span> {
      <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">schedule</span></span>(promise: <span class="hljs-type">Promise</span>[<span class="hljs-type">Unit</span>, <span class="hljs-type">Int</span>]): <span class="hljs-type">ZIO</span>[<span class="hljs-type">Any</span>, <span class="hljs-type">Exception</span>, <span class="hljs-type">Boolean</span>] =
        (<span class="hljs-type">ZIO</span>.sleep(<span class="hljs-number">10.</span>seconds) *&gt; promise.succeed(<span class="hljs-number">1</span>))
          .tap(b =&gt; <span class="hljs-type">ZIO</span>.service[<span class="hljs-type">LoggingService</span>].flatMap(_.log(b.toString)))
          .provide(env)
    }
}
<span class="hljs-comment">// schedulingLayer: ZLayer[Clock with Has[LoggingService], Nothing, Has[SchedulingService]] = Managed(</span>
<span class="hljs-comment">//   self = zio.ZManaged$$anon$2@410ca2cc</span>
<span class="hljs-comment">// )</span>

testM(<span class="hljs-string">"One can control time for failing effects too"</span>) {
  <span class="hljs-keyword">val</span> failingLogger = <span class="hljs-type">ZLayer</span>.succeed(<span class="hljs-keyword">new</span> <span class="hljs-type">LoggingService</span> {
    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">log</span></span>(msg: <span class="hljs-type">String</span>): <span class="hljs-type">ZIO</span>[<span class="hljs-type">Any</span>, <span class="hljs-type">Exception</span>, <span class="hljs-type">Unit</span>] = <span class="hljs-type">ZIO</span>.fail(<span class="hljs-keyword">new</span> <span class="hljs-type">Exception</span>(<span class="hljs-string">"BOOM"</span>))
  })

  <span class="hljs-keyword">val</span> partialLayer = (<span class="hljs-type">ZLayer</span>.identity[<span class="hljs-type">Clock</span>] ++ failingLogger) &gt;&gt;&gt; schedulingLayer

  <span class="hljs-keyword">val</span> testCase =
    <span class="hljs-keyword">for</span> {
      promise &lt;- <span class="hljs-type">Promise</span>.make[<span class="hljs-type">Unit</span>, <span class="hljs-type">Int</span>]
      result  &lt;- <span class="hljs-type">ZIO</span>.service[<span class="hljs-type">SchedulingService</span>].flatMap(_.schedule(promise)).run.fork
      _       &lt;- <span class="hljs-type">TestClock</span>.adjust(<span class="hljs-number">10.</span>seconds)
      readRef &lt;- promise.await
      result  &lt;- result.join
    } <span class="hljs-keyword">yield</span> assert(<span class="hljs-number">1</span>)(equalTo(readRef)) &amp;&amp; assert(result)(fails(isSubtype[<span class="hljs-type">Exception</span>](anything)))
  testCase.provideSomeLayer[<span class="hljs-type">TestEnvironment</span>](partialLayer)
}
<span class="hljs-comment">// res9: ZSpec[TestEnvironment, Unit] = Spec(</span>
<span class="hljs-comment">//   caseValue = TestCase(</span>
<span class="hljs-comment">//     label = "One can control time for failing effects too",</span>
<span class="hljs-comment">//     test = &lt;function1&gt;,</span>
<span class="hljs-comment">//     annotations = Map(zio.test.TestAnnotation@fa40ba79 -&gt; List(SourceLocation(test_effects.md,315)))</span>
<span class="hljs-comment">//   )</span>
<span class="hljs-comment">// )</span>
</code></pre>
<p>In this case we want to test a layered effect that can potentially fail with an error. To do this we need to run the effect
and use assertions that expect an <code>Exit</code> value.
Because we are providing a layer to the test we need to provide everything expected by our test case and leave the test
environment behind using <code>.provideSomeLayer[TestEnvironment]</code>. Keep in mind we do not provide any implementation of the <code>Clock</code>
because doing will make force <code>SchedulingService</code> to use it, while the clock we need here is the <code>TestClock</code> provided by
the test environment.</p>
<p>The pattern with <code>Promise</code> and <code>await</code> can be generalized when we need to wait for multiple values using a <code>Queue</code>. We simply need to put multiple values into the queue and progress the clock multiple times and there is no need to create multiple promises. Even if you have a non-trivial flow of data from multiple streams that can produce at different intervals and would like to test snapshots of data in particular point in time <code>Queue</code> can help with that.</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> zio.duration._
<span class="hljs-keyword">import</span> zio.test.<span class="hljs-type">Assertion</span>.equalTo
<span class="hljs-keyword">import</span> zio.test._
<span class="hljs-keyword">import</span> zio.test.environment.<span class="hljs-type">TestClock</span>
<span class="hljs-keyword">import</span> zio.stream._

testM(<span class="hljs-string">"zipWithLatest"</span>) {
  <span class="hljs-keyword">val</span> s1 = <span class="hljs-type">Stream</span>.iterate(<span class="hljs-number">0</span>)(_ + <span class="hljs-number">1</span>).fixed(<span class="hljs-number">100.</span>milliseconds)
  <span class="hljs-keyword">val</span> s2 = <span class="hljs-type">Stream</span>.iterate(<span class="hljs-number">0</span>)(_ + <span class="hljs-number">1</span>).fixed(<span class="hljs-number">70.</span>milliseconds)
  <span class="hljs-keyword">val</span> s3 = s1.zipWithLatest(s2)((_, _))

  <span class="hljs-keyword">for</span> {
    q      &lt;- <span class="hljs-type">Queue</span>.unbounded[(<span class="hljs-type">Int</span>, <span class="hljs-type">Int</span>)]
    _      &lt;- s3.foreach(q.offer).fork
    fiber  &lt;- <span class="hljs-type">ZIO</span>.collectAll(<span class="hljs-type">ZIO</span>.replicate(<span class="hljs-number">4</span>)(q.take)).fork
    _      &lt;- <span class="hljs-type">TestClock</span>.adjust(<span class="hljs-number">1.</span>second)
    result &lt;- fiber.join
  } <span class="hljs-keyword">yield</span> assert(result)(equalTo(<span class="hljs-type">List</span>(<span class="hljs-number">0</span> -&gt; <span class="hljs-number">0</span>, <span class="hljs-number">0</span> -&gt; <span class="hljs-number">1</span>, <span class="hljs-number">1</span> -&gt; <span class="hljs-number">1</span>, <span class="hljs-number">1</span> -&gt; <span class="hljs-number">2</span>)))
}
<span class="hljs-comment">// res10: ZSpec[Any with Clock with TestClock, Nothing] = Spec(</span>
<span class="hljs-comment">//   caseValue = TestCase(</span>
<span class="hljs-comment">//     label = "zipWithLatest",</span>
<span class="hljs-comment">//     test = &lt;function1&gt;,</span>
<span class="hljs-comment">//     annotations = Map(zio.test.TestAnnotation@fa40ba79 -&gt; List(SourceLocation(test_effects.md,352)))</span>
<span class="hljs-comment">//   )</span>
<span class="hljs-comment">// )</span>
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="testing-console"></a><a href="#testing-console" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Testing Console</h3>
<p><code>TestConsole</code> allows testing of applications that interact with console by modeling working with standard input and output
as writing and reading to and from internal buffers.</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> zio.test.environment.<span class="hljs-type">TestConsole</span>
<span class="hljs-keyword">import</span> zio.console

<span class="hljs-keyword">val</span> consoleSuite = suite(<span class="hljs-string">"ConsoleTest"</span>)(
  testM(<span class="hljs-string">"One can test output of console"</span>) {
    <span class="hljs-keyword">for</span> {
      _              &lt;- <span class="hljs-type">TestConsole</span>.feedLines(<span class="hljs-string">"Jimmy"</span>, <span class="hljs-string">"37"</span>)
      _              &lt;- console.putStrLn(<span class="hljs-string">"What is your name?"</span>)
      name           &lt;- console.getStrLn
      _              &lt;- console.putStrLn(<span class="hljs-string">"What is your age?"</span>)
      age            &lt;- console.getStrLn.map(_.toInt)
      questionVector &lt;- <span class="hljs-type">TestConsole</span>.output
      q1             = questionVector(<span class="hljs-number">0</span>)
      q2             = questionVector(<span class="hljs-number">1</span>)
    } <span class="hljs-keyword">yield</span> {
      assert(name)(equalTo(<span class="hljs-string">"Jimmy"</span>)) &amp;&amp;
      assert(age)(equalTo(<span class="hljs-number">37</span>)) &amp;&amp;
      assert(q1)(equalTo(<span class="hljs-string">"What is your name?\n"</span>)) &amp;&amp;
      assert(q2)(equalTo(<span class="hljs-string">"What is your age?\n"</span>))
    }
  }
)
<span class="hljs-comment">// consoleSuite: Spec[console.package.Console with TestConsole, TestFailure[java.io.IOException], TestSuccess] = Spec(</span>
<span class="hljs-comment">//   caseValue = SuiteCase(</span>
<span class="hljs-comment">//     label = "ConsoleTest",</span>
<span class="hljs-comment">//     specs = zio.ZManaged$$anon$2@235f5245,</span>
<span class="hljs-comment">//     exec = None</span>
<span class="hljs-comment">//   )</span>
<span class="hljs-comment">// )</span>
</code></pre>
<p>Above code simulates an application that will ask for name and age of the user. To test it we prefill buffers with answers
with call to <code>TestConsole.feedLines</code> method. Calls to <code>console.getStrLn</code> will get the value from the buffers instead of
interacting with the users keyboard. Also all output that our program produces by calling <code>console.putStrLn</code> (and other
printing methods) is being gathered and can be accessed with call to <code>TestConsole.output</code>.</p>
<h3><a class="anchor" aria-hidden="true" id="testing-system"></a><a href="#testing-system" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Testing System</h3>
<p>With increased usage of containers and runtimes like Kubernetes more and more applications are being configured by means
of environment variables. It is important to test this logic just like other parts of application. For this purpose <code>zio-test</code>
exposes <code>TestSystem</code> module. Additionally to setting the environment variables it also allows for setting JVM system properties
like in the code below:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> zio.system
<span class="hljs-keyword">import</span> zio.test.environment._

<span class="hljs-keyword">for</span> {
  _      &lt;- <span class="hljs-type">TestSystem</span>.putProperty(<span class="hljs-string">"java.vm.name"</span>, <span class="hljs-string">"VM"</span>)
  result &lt;- system.property(<span class="hljs-string">"java.vm.name"</span>)
} <span class="hljs-keyword">yield</span> assert(result)(equalTo(<span class="hljs-type">Some</span>(<span class="hljs-string">"VM"</span>)))
<span class="hljs-comment">// res11: ZIO[TestSystem with system.package.System, Throwable, TestResult] = zio.ZIO$FlatMap@2ad4de98</span>
</code></pre>
<p>It is worth noticing that no actual environment variables or properties will be set during testing so there will be
no impact on other parts of the system.</p>
<h2><a class="anchor" aria-hidden="true" id="test-aspects"></a><a href="#test-aspects" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Test Aspects</h2>
<p>Test aspects are used to modify existing tests or even entire suites that you have already created. Test aspects are
applied to a test or suite using the <code>@@</code> operator. This is an example test suite showing the use of aspects to modify
test behavior:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> zio.duration._
<span class="hljs-keyword">import</span> zio.test.<span class="hljs-type">Assertion</span>._
<span class="hljs-keyword">import</span> zio.test.<span class="hljs-type">TestAspect</span>._
<span class="hljs-keyword">import</span> zio.test._

<span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">MySpec</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">DefaultRunnableSpec</span> </span>{
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">spec</span> </span>= suite(<span class="hljs-string">"A Suite"</span>)(
    test(<span class="hljs-string">"A passing test"</span>) {
      assert(<span class="hljs-literal">true</span>)(isTrue)
    },
    test(<span class="hljs-string">"A passing test run for JVM only"</span>) {
      assert(<span class="hljs-literal">true</span>)(isTrue)
    } @@ jvmOnly, <span class="hljs-comment">//@@ jvmOnly only runs tests on the JVM</span>
    test(<span class="hljs-string">"A passing test run for JS only"</span>) {
      assert(<span class="hljs-literal">true</span>)(isTrue)
    } @@ jsOnly, <span class="hljs-comment">//@@ jsOnly only runs tests on Scala.js</span>
    test(<span class="hljs-string">"A passing test with a timeout"</span>) {
      assert(<span class="hljs-literal">true</span>)(isTrue)
    } @@ timeout(<span class="hljs-number">10.</span>nanos), <span class="hljs-comment">//@@ timeout will fail a test that doesn't pass within the specified time</span>
    test(<span class="hljs-string">"A failing test... that passes"</span>) {
      assert(<span class="hljs-literal">true</span>)(isFalse)
    } @@ failing, <span class="hljs-comment">//@@ failing turns a failing test into a passing test</span>
    test(<span class="hljs-string">"A ignored test"</span>) {
      assert(<span class="hljs-literal">false</span>)(isTrue)
    } @@ ignore, <span class="hljs-comment">//@@ ignore marks test as ignored</span>
    test(<span class="hljs-string">"A flaky test that only works on the JVM and sometimes fails; let's compose some aspects!"</span>) {
      assert(<span class="hljs-literal">false</span>)(isTrue)
    } @@ jvmOnly           <span class="hljs-comment">// only run on the JVM</span>
      @@ eventually        <span class="hljs-comment">//@@ eventually retries a test indefinitely until it succeeds</span>
      @@ timeout(<span class="hljs-number">20.</span>nanos) <span class="hljs-comment">//it's a good idea to compose `eventually` with `timeout`, or the test may never end</span>
  ) @@ timeout(<span class="hljs-number">60.</span>seconds)   <span class="hljs-comment">//apply a timeout to the whole suite</span>
}
</code></pre>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/docs/howto/use-test-assertions"><span class="arrow-prev">← </span><span>How to Use Test Assertions</span></a><a class="docs-next button" href="/docs/howto/mock-services"><span>How to Mock Services?</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#how-zio-test-was-designed">How zio-test was designed</a></li><li><a href="#constructing-tests">Constructing tests</a><ul class="toc-headings"><li><a href="#assertions---creating-testresults">Assertions - creating TestResults</a></li><li><a href="#running-tests">Running tests</a></li></ul></li><li><a href="#using-test-environment">Using Test Environment</a><ul class="toc-headings"><li><a href="#testing-random">Testing Random</a></li><li><a href="#testing-clock">Testing Clock</a></li><li><a href="#testing-console">Testing Console</a></li><li><a href="#testing-system">Testing System</a></li></ul></li><li><a href="#test-aspects">Test Aspects</a></li></ul></nav></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/" class="nav-home"><img src="/img/navbar_brand.png" alt="ZIO"/></a><div><h5>GitHub</h5><a href="https://github.com/zio/zio"><img src="https://img.shields.io/github/stars/zio/zio?style=social" alt="github"/></a></div><div><h5>Chat with us on Discord</h5><a href="https://discord.gg/2ccFBr4"><img src="https://img.shields.io/discord/629491597070827530?logo=discord&amp;style=social" alt="discord"/></a></div><div><h5>Follow us on Twitter</h5><a href="https://twitter.com/zioscala"><img src="https://img.shields.io/twitter/follow/zioscala?label=Follow&amp;style=social" alt="twitter"/></a></div><div><h5>Additional resources</h5><a href="https://javadoc.io/doc/dev.zio/zio_2.12/">Scaladoc of zio</a></div><div><a href="https://www.netlify.com"><img src="https://www.netlify.com/img/global/badges/netlify-color-accent.svg" alt="Deploys by Netlify"/></a></div></section><section class="copyright">Copyright © 2021 ZIO Maintainers</section></footer></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
                document.addEventListener('keyup', function(e) {
                  if (e.target !== document.body) {
                    return;
                  }
                  // keyCode for '/' (slash)
                  if (e.keyCode === 191) {
                    const search = document.getElementById('search_input_react');
                    search && search.focus();
                  }
                });
              </script><script>
              var search = docsearch({
                
                apiKey: '0c94b59071da7001757d08ab43d9e033',
                indexName: 'zio',
                inputSelector: '#search_input_react',
                algoliaOptions: {}
              });
            </script></body></html>