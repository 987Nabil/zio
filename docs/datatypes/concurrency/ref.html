<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Ref · ZIO</title><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta name="generator" content="Docusaurus"/><meta name="description" content="`Ref[A]` models a **mutable reference** to a value of type `A` in which we can store **immutable** data. The two basic operations are `set`, which fills the `Ref` with a new value, and `get`, which retrieves its current content. All operations on a `Ref` are atomic and thread-safe, providing a reliable foundation for synchronizing concurrent programs."/><meta name="docsearch:language" content="en"/><meta property="og:title" content="Ref · ZIO"/><meta property="og:type" content="website"/><meta property="og:url" content="https://zio.dev/"/><meta property="og:description" content="`Ref[A]` models a **mutable reference** to a value of type `A` in which we can store **immutable** data. The two basic operations are `set`, which fills the `Ref` with a new value, and `get`, which retrieves its current content. All operations on a `Ref` are atomic and thread-safe, providing a reliable foundation for synchronizing concurrent programs."/><meta name="twitter:card" content="summary"/><link rel="shortcut icon" href="/img/favicon.png"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script src="https://unpkg.com/vanilla-back-to-top@7.1.14/dist/vanilla-back-to-top.min.js"></script><script>
        document.addEventListener('DOMContentLoaded', function() {
          addBackToTop(
            {"zIndex":100,"cornerOffset":100}
          )
        });
        </script><script src="/js/scrollSpy.js"></script><link rel="stylesheet" href="/css/main.css"/><script src="/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/"><img class="logo" src="/img/navbar_brand.png" alt="ZIO"/><h2 class="headerTitleWithLogo">ZIO</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class=""><a href="/docs/overview/overview_index" target="_self">Overview</a></li><li class="siteNavGroupActive"><a href="/docs/datatypes/" target="_self">Data Types</a></li><li class=""><a href="/docs/services/" target="_self">Services</a></li><li class=""><a href="/docs/usecases/usecases_index" target="_self">Use Cases</a></li><li class=""><a href="/docs/howto/" target="_self">How to</a></li><li class=""><a href="/docs/resources/" target="_self">Resources</a></li><li class=""><a href="/docs/about/about_index" target="_self">About</a></li><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search" title="Search"/></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>Concurrency Primitives</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">Overview<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/docs/datatypes/">Introduction</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">Core Data Types<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/docs/datatypes/core/">Summary</a></li><li class="navListItem"><a class="navItem" href="/docs/datatypes/core/zio">ZIO</a></li><li class="navListItem"><a class="navItem" href="/docs/datatypes/core/uio">UIO</a></li><li class="navListItem"><a class="navItem" href="/docs/datatypes/core/urio">URIO</a></li><li class="navListItem"><a class="navItem" href="/docs/datatypes/core/task">Task</a></li><li class="navListItem"><a class="navItem" href="/docs/datatypes/core/rio">RIO</a></li><li class="navListItem"><a class="navItem" href="/docs/datatypes/core/io">IO</a></li><li class="navListItem"><a class="navItem" href="/docs/datatypes/core/exit">Exit</a></li><li class="navListItem"><a class="navItem" href="/docs/datatypes/core/cause">Cause</a></li><li class="navListItem"><a class="navItem" href="/docs/datatypes/core/runtime">Runtime</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">Contextual Types<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/docs/datatypes/contextual/">Introduction</a></li><li class="navListItem"><a class="navItem" href="/docs/datatypes/contextual/has">Has</a></li><li class="navListItem"><a class="navItem" href="/docs/datatypes/contextual/zlayer">ZLayer</a></li><li class="navListItem"><a class="navItem" href="/docs/datatypes/contextual/rlayer">RLayer</a></li><li class="navListItem"><a class="navItem" href="/docs/datatypes/contextual/ulayer">ULayer</a></li><li class="navListItem"><a class="navItem" href="/docs/datatypes/contextual/layer">Layer</a></li><li class="navListItem"><a class="navItem" href="/docs/datatypes/contextual/urlayer">URLayer</a></li><li class="navListItem"><a class="navItem" href="/docs/datatypes/contextual/tasklayer">TaskLayer</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">Fiber Primitives<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/docs/datatypes/fiber/">Introduction</a></li><li class="navListItem"><a class="navItem" href="/docs/datatypes/fiber/fiber">Fiber</a></li><li class="navListItem"><a class="navItem" href="/docs/datatypes/fiber/fiberref">FiberRef</a></li><li class="navListItem"><a class="navItem" href="/docs/datatypes/fiber/fiberid">Fiber.Id</a></li><li class="navListItem"><a class="navItem" href="/docs/datatypes/fiber/fiberstatus">Fiber.Status</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">Concurrency Primitives<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/docs/datatypes/concurrency/">Introduction</a></li><li class="navListItem"><a class="navItem" href="/docs/datatypes/concurrency/zref">ZRef</a></li><li class="navListItem navListItemActive"><a class="navItem" href="/docs/datatypes/concurrency/ref">Ref</a></li><li class="navListItem"><a class="navItem" href="/docs/datatypes/concurrency/zrefm">ZRefM</a></li><li class="navListItem"><a class="navItem" href="/docs/datatypes/concurrency/refm">RefM</a></li><li class="navListItem"><a class="navItem" href="/docs/datatypes/concurrency/promise">Promise</a></li><li class="navListItem"><a class="navItem" href="/docs/datatypes/concurrency/queue">Queue</a></li><li class="navListItem"><a class="navItem" href="/docs/datatypes/concurrency/hub">Hub</a></li><li class="navListItem"><a class="navItem" href="/docs/datatypes/concurrency/semaphore">Semaphore</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">STM<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/docs/datatypes/stm/">Introduction</a></li><li class="navListItem"><a class="navItem" href="/docs/datatypes/stm/stm">STM</a></li><li class="navListItem"><a class="navItem" href="/docs/datatypes/stm/tarray">TArray</a></li><li class="navListItem"><a class="navItem" href="/docs/datatypes/stm/tset">TSet</a></li><li class="navListItem"><a class="navItem" href="/docs/datatypes/stm/tmap">TMap</a></li><li class="navListItem"><a class="navItem" href="/docs/datatypes/stm/tref">TRef</a></li><li class="navListItem"><a class="navItem" href="/docs/datatypes/stm/tpriorityqueue">TPriorityQueue</a></li><li class="navListItem"><a class="navItem" href="/docs/datatypes/stm/tpromise">TPromise</a></li><li class="navListItem"><a class="navItem" href="/docs/datatypes/stm/tqueue">TQueue</a></li><li class="navListItem"><a class="navItem" href="/docs/datatypes/stm/treentrantlock">TReentrantLock</a></li><li class="navListItem"><a class="navItem" href="/docs/datatypes/stm/tsemaphore">TSemaphore</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">Resource Safety<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/docs/datatypes/resource/">Introduction</a></li><li class="navListItem"><a class="navItem" href="/docs/datatypes/resource/zmanaged">ZManaged</a></li><li class="navListItem"><a class="navItem" href="/docs/datatypes/resource/managed">Managed</a></li><li class="navListItem"><a class="navItem" href="/docs/datatypes/resource/task-managed">TaskManaged</a></li><li class="navListItem"><a class="navItem" href="/docs/datatypes/resource/rmanaged">RManaged</a></li><li class="navListItem"><a class="navItem" href="/docs/datatypes/resource/umanaged">UManaged</a></li><li class="navListItem"><a class="navItem" href="/docs/datatypes/resource/urmanaged">URManaged</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">Streaming<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/docs/datatypes/stream/">Introduction</a></li><li class="navListItem"><a class="navItem" href="/docs/datatypes/stream/zstream">ZStream</a></li><li class="navListItem"><a class="navItem" href="/docs/datatypes/stream/stream">Stream</a></li><li class="navListItem"><a class="navItem" href="/docs/datatypes/stream/ustream">UStream</a></li><li class="navListItem"><a class="navItem" href="/docs/datatypes/stream/ztransducer">ZTransducer</a></li><li class="navListItem"><a class="navItem" href="/docs/datatypes/stream/transducer">Transducer</a></li><li class="navListItem"><a class="navItem" href="/docs/datatypes/stream/zsink">ZSink</a></li><li class="navListItem"><a class="navItem" href="/docs/datatypes/stream/sink">Sink</a></li><li class="navListItem"><a class="navItem" href="/docs/datatypes/stream/subscription-ref">SubscriptionRef</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">Miscellaneous<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/docs/datatypes/misc/">Summary</a></li><li class="navListItem"><a class="navItem" href="/docs/datatypes/misc/chunk">Chunk</a></li><li class="navListItem"><a class="navItem" href="/docs/datatypes/misc/schedule">Schedule</a></li><li class="navListItem"><a class="navItem" href="/docs/datatypes/misc/supervisor">Supervisor</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer docsContainer"><div class="wrapper"><div class="post"><header class="postHeader"><a class="edit-page-link button" href="https://github.com/zio/zio/edit/master/docs/datatypes/concurrency/ref.md" target="_blank" rel="noreferrer noopener">Edit</a><h1 id="__docusaurus" class="postHeaderTitle">Ref</h1></header><article><div><span><p><code>Ref[A]</code> models a <strong>mutable reference</strong> to a value of type <code>A</code> in which we can store <strong>immutable</strong> data. The two basic operations are <code>set</code>, which fills the <code>Ref</code> with a new value, and <code>get</code>, which retrieves its current content. All operations on a <code>Ref</code> are atomic and thread-safe, providing a reliable foundation for synchronizing concurrent programs.</p>
<p><code>Ref</code> is ZIO's analog to something like a State Monad in more Haskell-Oriented FP. We don't need State Monad in ZIO, because we have <code>Ref</code>s. <code>Ref</code>s allow us to get and set state, or update it.</p>
<p>When we write stateful applications, we need some mechanism to manage our state. We need a way to update the in-memory state in a functional way. So this is why we need <code>Ref</code>s.</p>
<p><code>Ref</code>s are:</p>
<ul>
<li>Purely Functional and Referential Transparent</li>
<li>Concurrent-Safe and Lock-free</li>
<li>Update and Modify atomically</li>
</ul>
<h2><a class="anchor" aria-hidden="true" id="concurrent-stateful-application"></a><a href="#concurrent-stateful-application" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Concurrent Stateful Application</h2>
<p><strong><code>Ref</code>s are building blocks for writing concurrent stateful applications</strong>. Without <code>Ref</code> or something equivalently, we can't do that. Anytime we need to share information between multiple fibers, and those fibers have to update the same information, they need to communicate through something that provides the guarantee of atomicity. So <code>Ref</code>s can update the state in an atomic way, consistent and isolated from all other concurrent updates.</p>
<p><strong><code>Ref</code>s are concurrent-safe</strong>. we can share the same <code>Ref</code> among many fibers. All of them can update <code>Ref</code> concurrently. We don't have to worry about race conditions. Even we have ten thousand fibers all updating the same <code>Ref</code> as long as they are using atomic update and modify functions, we will have zero race conditions.</p>
<h2><a class="anchor" aria-hidden="true" id="operations"></a><a href="#operations" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Operations</h2>
<p>The <code>Ref</code> has lots of operations. Here we are going to introduce the most important and common ones. Also, note that <code>Ref</code> is a type alias for <code>ZRef</code>. <code>ZRef</code> has many type parameters. Basically, all of these type parameters on <code>ZRef</code> are useful for the more advanced operators. So as a not advanced user, don't worry about them.</p>
<h3><a class="anchor" aria-hidden="true" id="make"></a><a href="#make" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>make</h3>
<p><code>Ref</code> is never empty and it always contains something. We can create <code>Ref</code> by providing the initial value to the <code>make</code>,  which is a constructor of the <code>Ref</code> data type. We should pass an <strong>immutable value</strong> of type <code>A</code> to the constructor, and it returns an <code>UIO[Ref[A]]</code> value:</p>
<pre><code class="hljs css language-scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">make</span></span>[<span class="hljs-type">A</span>](a: <span class="hljs-type">A</span>): <span class="hljs-type">UIO</span>[<span class="hljs-type">Ref</span>[<span class="hljs-type">A</span>]]
</code></pre>
<p>As we can see, the output is wrapped in <code>UIO</code>, which means creating <code>Ref</code> is effectful. Whenever we <code>make</code>, <code>update</code>, or <code>modify</code> the <code>Ref</code>, we are doing some effectful operation, this is why their output is wrapped in <code>UIO</code>. It helps the API remain referential transparent.</p>
<p>Let's create some <code>Ref</code>s from immutable values:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">val</span> counterRef = <span class="hljs-type">Ref</span>.make(<span class="hljs-number">0</span>)
<span class="hljs-comment">// counterRef: UIO[Ref[Int]] = zio.ZIO$EffectTotal@2fb281d8</span>
<span class="hljs-keyword">val</span> stringRef = <span class="hljs-type">Ref</span>.make(<span class="hljs-string">"initial"</span>) 
<span class="hljs-comment">// stringRef: UIO[Ref[String]] = zio.ZIO$EffectTotal@30d748f2 </span>

<span class="hljs-keyword">sealed</span> <span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">State</span></span>
<span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Active</span>  <span class="hljs-keyword">extends</span> <span class="hljs-title">State</span></span>
<span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Changed</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">State</span></span>
<span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Closed</span>  <span class="hljs-keyword">extends</span> <span class="hljs-title">State</span></span>

<span class="hljs-keyword">val</span> stateRef = <span class="hljs-type">Ref</span>.make(<span class="hljs-type">Active</span>) 
<span class="hljs-comment">// stateRef: UIO[Ref[Active.type]] = zio.ZIO$EffectTotal@673d045f</span>
</code></pre>
<blockquote>
<p><em><strong>Warning</strong></em>:</p>
<p>The big mistake to creating <code>Ref</code> is trying to store mutable data inside it. It doesn't work. The only way to use a <code>Ref</code> is to store <strong>immutable data</strong> inside it, otherwise, it does not provide us atomic guarantees, and we can have collisions and race conditions.</p>
</blockquote>
<p>As we mentioned above, we shouldn't create <code>Ref</code> from a mutable variable. The following snippet compiles, but it leads us to race conditions due to improper use of <code>make</code>:</p>
<pre><code class="hljs css language-scala"><span class="hljs-comment">// Compiles but don't work properly</span>
<span class="hljs-keyword">var</span> init = <span class="hljs-number">0</span>
<span class="hljs-comment">// init: Int = 0</span>
<span class="hljs-keyword">val</span> counterRef = <span class="hljs-type">Ref</span>.make(init)
<span class="hljs-comment">// counterRef: UIO[Ref[Int]] = zio.ZIO$EffectTotal@4dae4228</span>
</code></pre>
<p>So we should change the <code>init</code> to be immutable:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">val</span> init = <span class="hljs-number">0</span>
<span class="hljs-comment">// init: Int = 0</span>
<span class="hljs-keyword">val</span> counterRef = <span class="hljs-type">Ref</span>.make(init)
<span class="hljs-comment">// counterRef: UIO[Ref[Int]] = zio.ZIO$EffectTotal@449d4a7e</span>
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="get"></a><a href="#get" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>get</h3>
<p>The <code>get</code> method returns the current value of the reference. Its return type is <code>IO[EB, B]</code>. Which <code>B</code> is the value type of returning effect and in the failure case, <code>EB</code> is the error type of that effect.</p>
<pre><code class="hljs css language-scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get</span></span>: <span class="hljs-type">IO</span>[<span class="hljs-type">EB</span>, <span class="hljs-type">B</span>]
</code></pre>
<p>As the <code>make</code> and <code>get</code> methods of <code>Ref</code> are effectful, we can chain them together with flatMap. In the following example, we create a <code>Ref</code> with <code>initial</code> value, and then we acquire the current state with the <code>get</code> method:</p>
<pre><code class="hljs css language-scala"><span class="hljs-type">Ref</span>.make(<span class="hljs-string">"initial"</span>)
   .flatMap(_.get)
   .flatMap(current =&gt; putStrLn(<span class="hljs-string">s"current value of ref: <span class="hljs-subst">$current</span>"</span>))
</code></pre>
<p>We can use syntactic sugar representation of flatMap series with for-comprehension:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">for</span> {
  ref   &lt;- <span class="hljs-type">Ref</span>.make(<span class="hljs-string">"initial"</span>)
  value &lt;- ref.get
} <span class="hljs-keyword">yield</span> assert(value == <span class="hljs-string">"initial"</span>)
</code></pre>
<p>Note that, there is no way to access the shared state outside the monadic operations.</p>
<h3><a class="anchor" aria-hidden="true" id="set"></a><a href="#set" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>set</h3>
<p>The <code>set</code> method atomically writes a new value to the <code>Ref</code>.</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">for</span> {
  ref   &lt;- <span class="hljs-type">Ref</span>.make(<span class="hljs-string">"initial"</span>)
  _     &lt;- ref.set(<span class="hljs-string">"update"</span>)
  value &lt;- ref.get
} <span class="hljs-keyword">yield</span> assert(value == <span class="hljs-string">"update"</span>)
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="update"></a><a href="#update" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>update</h3>
<p>With <code>update</code>, we can atomically update the state of <code>Ref</code> with a given <strong>pure</strong> function. A function that we pass to the <code>update</code> needs to be a pure function, it needs to be deterministic and free of side effects.</p>
<pre><code class="hljs css language-scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">update</span></span>(f: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">A</span>): <span class="hljs-type">IO</span>[<span class="hljs-type">E</span>, <span class="hljs-type">Unit</span>]
</code></pre>
<p>Assume we have a counter, we can increase its value with the <code>update</code> method:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">val</span> counterInitial = <span class="hljs-number">0</span>
<span class="hljs-keyword">for</span> {
  counterRef &lt;- <span class="hljs-type">Ref</span>.make(counterInitial)
  _          &lt;- counterRef.update(_ + <span class="hljs-number">1</span>)
  value &lt;- counterRef.get
} <span class="hljs-keyword">yield</span> assert(value == <span class="hljs-number">1</span>)
</code></pre>
<blockquote>
<p><em><strong>Note</strong></em>:</p>
<p>The <code>update</code> is not the composition of <code>get</code> and <code>set</code>, this composition is not concurrently safe. So whenever we need to update our state, we should not compose <code>get</code> and <code>set</code> to manage our state in a concurrent environment. Instead, we should use the <code>update</code> operation which modifies its <code>Ref</code> atomically.</p>
</blockquote>
<p>The following snippet is not concurrent safe:</p>
<pre><code class="hljs css language-scala"><span class="hljs-comment">// Unsafe State Management</span>
<span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">UnsafeCountRequests</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">zio</span>.<span class="hljs-title">App</span> </span>{
  <span class="hljs-keyword">import</span> zio.console._

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">request</span></span>(counter: <span class="hljs-type">Ref</span>[<span class="hljs-type">Int</span>]) = <span class="hljs-keyword">for</span> {
    current &lt;- counter.get
    _ &lt;- counter.set(current + <span class="hljs-number">1</span>)
  } <span class="hljs-keyword">yield</span> ()

  <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> initial = <span class="hljs-number">0</span>
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> program =
    <span class="hljs-keyword">for</span> {
      ref &lt;- <span class="hljs-type">Ref</span>.make(initial)
      _ &lt;- request(ref) zipPar request(ref)
      rn &lt;- ref.get
      _ &lt;- putStrLn(<span class="hljs-string">s"total requests performed: <span class="hljs-subst">$rn</span>"</span>)
    } <span class="hljs-keyword">yield</span> ()

  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span></span>(args: <span class="hljs-type">List</span>[<span class="hljs-type">String</span>]) = program.exitCode
}
</code></pre>
<p>The above snippet doesn't behave deterministically. This program sometimes print 2 and sometime print 1. So let's fix that issue by using <code>update</code> which behaves atomically:</p>
<pre><code class="hljs css language-scala"><span class="hljs-comment">// Unsafe State Management</span>
<span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">CountRequests</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">zio</span>.<span class="hljs-title">App</span> </span>{
  <span class="hljs-keyword">import</span> zio.console._

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">request</span></span>(counter: <span class="hljs-type">Ref</span>[<span class="hljs-type">Int</span>]): <span class="hljs-type">ZIO</span>[<span class="hljs-type">Console</span>, <span class="hljs-type">Nothing</span>, <span class="hljs-type">Unit</span>] = {
    <span class="hljs-keyword">for</span> {
      _ &lt;- counter.update(_ + <span class="hljs-number">1</span>)
      reqNumber &lt;- counter.get
      _ &lt;- putStrLn(<span class="hljs-string">s"request number: <span class="hljs-subst">$reqNumber</span>"</span>).orDie
    } <span class="hljs-keyword">yield</span> ()
  }

  <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> initial = <span class="hljs-number">0</span>
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> program =
    <span class="hljs-keyword">for</span> {
      ref &lt;- <span class="hljs-type">Ref</span>.make(initial)
      _ &lt;- request(ref) zipPar request(ref)
      rn &lt;- ref.get
      _ &lt;- putStrLn(<span class="hljs-string">s"total requests performed: <span class="hljs-subst">$rn</span>"</span>).orDie
    } <span class="hljs-keyword">yield</span> ()

  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span></span>(args: <span class="hljs-type">List</span>[<span class="hljs-type">String</span>]) = program.exitCode
}
</code></pre>
<p>Here is another use case of <code>update</code> to write <code>repeat</code> combinator:</p>
<pre><code class="hljs css language-scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">repeat</span></span>[<span class="hljs-type">E</span>, <span class="hljs-type">A</span>](n: <span class="hljs-type">Int</span>)(io: <span class="hljs-type">IO</span>[<span class="hljs-type">E</span>, <span class="hljs-type">A</span>]): <span class="hljs-type">IO</span>[<span class="hljs-type">E</span>, <span class="hljs-type">Unit</span>] =
  <span class="hljs-type">Ref</span>.make(<span class="hljs-number">0</span>).flatMap { iRef =&gt;
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">loop</span></span>: <span class="hljs-type">IO</span>[<span class="hljs-type">E</span>, <span class="hljs-type">Unit</span>] = iRef.get.flatMap { i =&gt;
      <span class="hljs-keyword">if</span> (i &lt; n)
        io *&gt; iRef.update(_ + <span class="hljs-number">1</span>) *&gt; loop
      <span class="hljs-keyword">else</span>
        <span class="hljs-type">IO</span>.unit
    }
    loop
  }
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="modify"></a><a href="#modify" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>modify</h3>
<p><code>modify</code> is a more powerful version of the <code>update</code>. It atomically modifies its <code>Ref</code> with the given function and, also computes a return value. The function that we pass to the <code>modify</code> needs to be a pure function; it needs to be deterministic and free of side effects.</p>
<pre><code class="hljs css language-scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">modify</span></span>[<span class="hljs-type">B</span>](f: <span class="hljs-type">A</span> =&gt; (<span class="hljs-type">B</span>, <span class="hljs-type">A</span>)): <span class="hljs-type">IO</span>[<span class="hljs-type">E</span>, <span class="hljs-type">B</span>]
</code></pre>
<p>Remember the <code>CountRequest</code> example. What if we want to log the number of each request, inside the <code>request</code> function? Let's see what happen if we write that function with the composition of <code>update</code> and <code>get</code> methods:</p>
<pre><code class="hljs css language-scala"><span class="hljs-comment">// Unsafe in Concurrent Environment</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">request</span></span>(counter: <span class="hljs-type">Ref</span>[<span class="hljs-type">Int</span>]) = {
  <span class="hljs-keyword">for</span> {
    _  &lt;- counter.update(_ + <span class="hljs-number">1</span>)
    rn &lt;- counter.get
    _  &lt;- putStrLn(<span class="hljs-string">s"request number received: <span class="hljs-subst">$rn</span>"</span>)
  } <span class="hljs-keyword">yield</span> ()
}
</code></pre>
<p>What happens if between running the update and get, another update in another fiber performed? This function doesn't perform in a deterministic fashion in concurrent environments. So we need a way to perform <strong>get and set and get</strong> atomically. This is why we need the <code>modify</code> method. Let's fix the <code>request</code> function to do that atomically:</p>
<pre><code class="hljs css language-scala"><span class="hljs-comment">// Safe in Concurrent Environment</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">request</span></span>(counter: <span class="hljs-type">Ref</span>[<span class="hljs-type">Int</span>]) = {
  <span class="hljs-keyword">for</span> {
    rn &lt;- counter.modify(c =&gt; (c + <span class="hljs-number">1</span>, c + <span class="hljs-number">1</span>))
    _  &lt;- putStrLn(<span class="hljs-string">s"request number received: <span class="hljs-subst">$rn</span>"</span>)
  } <span class="hljs-keyword">yield</span> ()
}
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="atomicreference-in-java"></a><a href="#atomicreference-in-java" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>AtomicReference in Java</h2>
<p>For Java programmers, we can think of <code>Ref</code> as an AtomicReference. Java has a <code>java.util.concurrent.atomic</code> package and that package contains <code>AtomicReference</code>, <code>AtomicLong</code>, <code>AtomicBoolean</code> and so forth. We can think of <code>Ref</code> as being an <code>AtomicReference</code>. It has roughly the same power, the same guarantees, and the same limitations. It packages it up in a higher-level context and of course, makes it ZIO friendly.</p>
<h2><a class="anchor" aria-hidden="true" id="ref-vs-state-monad"></a><a href="#ref-vs-state-monad" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Ref vs. State Monad</h2>
<p>Basically <code>Ref</code> allows us to have all the power of State Monad inside ZIO. State Monad lacks two important features that we use in real-life application development:</p>
<ol>
<li>Concurrency Support</li>
<li>Error Handling</li>
</ol>
<h3><a class="anchor" aria-hidden="true" id="concurrency"></a><a href="#concurrency" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Concurrency</h3>
<p>State Monad is its effect system that only includes state. It allows us to do pure stateful computations. We can only get, set and update related computations to managing the state. State Monad updates its state with series of stateful computations sequentially, but <strong>we can't use the State Monad to do async or concurrent computations</strong>. But <code>Ref</code>s have great support on concurrent and async programming.</p>
<h3><a class="anchor" aria-hidden="true" id="error-handling"></a><a href="#error-handling" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Error Handling</h3>
<p>In real-life applications, we need error handling. In most real-life stateful applications, we will involve some database IO and API calls and or some concurrent and sync stuff that it can fail in different ways along the path of execution. So besides the state management, we need a way to do error handling. The State Monad doesn't have the ability to model error management.</p>
<p>We can combine State Monad and Either Monad with StateT monad transformer, but it imposes massive performance overhead. It doesn't buy us anything that we can't do with a Ref. So it is an anti-pattern. In the ZIO model, errors are encoded in effects and Ref utilizes that. So besides state management, we have the ability to error-handling without any further work.</p>
<h2><a class="anchor" aria-hidden="true" id="state-transformers"></a><a href="#state-transformers" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>State Transformers</h2>
<p>Those who live on the dark side of mutation sometimes have it easy; they can add state everywhere like it's Christmas. Behold:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">var</span> idCounter = <span class="hljs-number">0</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">freshVar</span></span>: <span class="hljs-type">String</span> = {
  idCounter += <span class="hljs-number">1</span>
  <span class="hljs-string">s"var<span class="hljs-subst">${idCounter}</span>"</span>
}
<span class="hljs-keyword">val</span> v1 = freshVar
<span class="hljs-keyword">val</span> v2 = freshVar
<span class="hljs-keyword">val</span> v3 = freshVar
</code></pre>
<p>As functional programmers, we know better and have captured state mutation in the form of functions of type <code>S =&gt; (A, S)</code>. <code>Ref</code> provides such an encoding, with <code>S</code> being the type of the value, and <code>modify</code> embodying the state mutation function.</p>
<pre><code class="hljs css language-scala"><span class="hljs-type">Ref</span>.make(<span class="hljs-number">0</span>).flatMap { idCounter =&gt;
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">freshVar</span></span>: <span class="hljs-type">UIO</span>[<span class="hljs-type">String</span>] =
    idCounter.modify(cpt =&gt; (<span class="hljs-string">s"var<span class="hljs-subst">${cpt + 1}</span>"</span>, cpt + <span class="hljs-number">1</span>))

  <span class="hljs-keyword">for</span> {
    v1 &lt;- freshVar
    v2 &lt;- freshVar
    v3 &lt;- freshVar
  } <span class="hljs-keyword">yield</span> ()
}
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="building-more-sophisticated-concurrency-primitives"></a><a href="#building-more-sophisticated-concurrency-primitives" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Building more sophisticated concurrency primitives</h2>
<p><code>Ref</code> is low-level enough that it can serve as the foundation for other concurrency data types.</p>
<p>Semaphores are a classic abstract data type for controlling access to shared resources. They are defined as a triple S = (v, P, V) where v is the number of units of the resource that are currently available, and P and V are operations that respectively decrement and increment v; P will only complete when v is non-negative and must wait if it isn't.</p>
<p>Well, with <code>Ref</code>s, that's easy to do! The only difficulty is in <code>P</code>, where we must fail and retry when either <code>v</code> is negative or its value has changed between the moment we read it and the moment we try to update it. A naive implementation could look like:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">sealed</span> <span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">S</span> </span>{
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">P</span></span>: <span class="hljs-type">UIO</span>[<span class="hljs-type">Unit</span>]
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">V</span></span>: <span class="hljs-type">UIO</span>[<span class="hljs-type">Unit</span>]
}

<span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">S</span> </span>{
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">apply</span></span>(v: <span class="hljs-type">Long</span>): <span class="hljs-type">UIO</span>[<span class="hljs-type">S</span>] =
    <span class="hljs-type">Ref</span>.make(v).map { vref =&gt;
      <span class="hljs-keyword">new</span> <span class="hljs-type">S</span> {
        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">V</span> </span>= vref.update(_ + <span class="hljs-number">1</span>).unit

        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">P</span> </span>= (vref.get.flatMap { v =&gt;
          <span class="hljs-keyword">if</span> (v &lt; <span class="hljs-number">0</span>)
            <span class="hljs-type">IO</span>.fail(())
          <span class="hljs-keyword">else</span>
            vref.modify(v0 =&gt; <span class="hljs-keyword">if</span> (v0 == v) (<span class="hljs-literal">true</span>, v - <span class="hljs-number">1</span>) <span class="hljs-keyword">else</span> (<span class="hljs-literal">false</span>, v)).flatMap {
              <span class="hljs-keyword">case</span> <span class="hljs-literal">false</span> =&gt; <span class="hljs-type">IO</span>.fail(())
              <span class="hljs-keyword">case</span> <span class="hljs-literal">true</span>  =&gt; <span class="hljs-type">IO</span>.unit
            }
        } &lt;&gt; <span class="hljs-type">P</span>).unit
      }
    }
}
</code></pre>
<p>Let's rock these crocodile boots we found the other day at the market and test our semaphore at the night club, yee-haw:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> zio.duration.<span class="hljs-type">Duration</span>
<span class="hljs-keyword">import</span> zio.clock._
<span class="hljs-keyword">import</span> zio.console._
<span class="hljs-keyword">import</span> zio.random._

<span class="hljs-keyword">val</span> party = <span class="hljs-keyword">for</span> {
  dancefloor &lt;- <span class="hljs-type">S</span>(<span class="hljs-number">10</span>)
  dancers &lt;- <span class="hljs-type">ZIO</span>.foreachPar(<span class="hljs-number">1</span> to <span class="hljs-number">100</span>) { i =&gt;
    dancefloor.<span class="hljs-type">P</span> *&gt; nextDouble.map(d =&gt; <span class="hljs-type">Duration</span>.fromNanos((d * <span class="hljs-number">1000000</span>).round)).flatMap { d =&gt;
      putStrLn(<span class="hljs-string">s"<span class="hljs-subst">${i}</span> checking my boots"</span>) *&gt; sleep(d) *&gt; putStrLn(<span class="hljs-string">s"<span class="hljs-subst">${i}</span> dancing like it's 99"</span>)
    } *&gt; dancefloor.<span class="hljs-type">V</span>
  }
} <span class="hljs-keyword">yield</span> ()
</code></pre>
<p>It goes without saying you should take a look at ZIO's own <code>Semaphore</code>, it does all this and more without wasting all those CPU cycles while waiting.</p>
<h2><a class="anchor" aria-hidden="true" id="polymorphic-refs"></a><a href="#polymorphic-refs" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Polymorphic <code>Ref</code>s</h2>
<p><code>Ref[A]</code> is actually a type alias for <code>ZRef[Nothing, Nothing, A, A]</code>. The type signature of <code>ZRef</code> is:</p>
<pre><code class="hljs css language-scala"><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">ZRef</span>[+<span class="hljs-type">EA</span>, +<span class="hljs-type">EB</span>, -<span class="hljs-type">A</span>, +<span class="hljs-type">B</span>]</span>
</code></pre>
<p>A <code>ZRef</code> is a polymorphic, purely functional description of a mutable reference. The fundamental operations of a <code>ZRef</code> are <code>set</code> and <code>get</code>. <code>set</code> takes a value of type <code>A</code> and sets the reference to a new value, potentially failing with an error of type <code>EA</code>. <code>get</code> gets the current value of the reference and returns a value of type <code>B</code>, potentially failing with an error of type <code>EB</code>.</p>
<p>When the error and value types of the <code>ZRef</code> are unified, that is, it is a <code>ZRef[E, E, A, A]</code>, the <code>ZRef</code> also supports atomic <code>modify</code> and <code>update</code> operations as discussed above.</p>
<p>A simple use case is passing out read-only or write-only views of a reference:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">for</span> {
  ref       &lt;- <span class="hljs-type">Ref</span>.make(<span class="hljs-literal">false</span>)
  readOnly  = ref.readOnly
  writeOnly = ref.writeOnly
  _         &lt;- writeOnly.set(<span class="hljs-literal">true</span>)
  value     &lt;- readOnly.get
} <span class="hljs-keyword">yield</span> value
</code></pre>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/docs/datatypes/concurrency/zref"><span class="arrow-prev">← </span><span>ZRef</span></a><a class="docs-next button" href="/docs/datatypes/concurrency/zrefm"><span class="function-name-prevnext">ZRefM</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#concurrent-stateful-application">Concurrent Stateful Application</a></li><li><a href="#operations">Operations</a><ul class="toc-headings"><li><a href="#make">make</a></li><li><a href="#get">get</a></li><li><a href="#set">set</a></li><li><a href="#update">update</a></li><li><a href="#modify">modify</a></li></ul></li><li><a href="#atomicreference-in-java">AtomicReference in Java</a></li><li><a href="#ref-vs-state-monad">Ref vs. State Monad</a><ul class="toc-headings"><li><a href="#concurrency">Concurrency</a></li><li><a href="#error-handling">Error Handling</a></li></ul></li><li><a href="#state-transformers">State Transformers</a></li><li><a href="#building-more-sophisticated-concurrency-primitives">Building more sophisticated concurrency primitives</a></li><li><a href="#polymorphic-refs">Polymorphic <code>Ref</code>s</a></li></ul></nav></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/" class="nav-home"><img src="/img/navbar_brand.png" alt="ZIO"/></a><div><h5>GitHub</h5><a href="https://github.com/zio/zio"><img src="https://img.shields.io/github/stars/zio/zio?style=social" alt="github"/></a></div><div><h5>Chat with us on Discord</h5><a href="https://discord.gg/2ccFBr4"><img src="https://img.shields.io/discord/629491597070827530?logo=discord&amp;style=social" alt="discord"/></a></div><div><h5>Follow us on Twitter</h5><a href="https://twitter.com/zioscala"><img src="https://img.shields.io/twitter/follow/zioscala?label=Follow&amp;style=social" alt="twitter"/></a></div><div><h5>Additional resources</h5><a href="https://javadoc.io/doc/dev.zio/zio_2.12/">Scaladoc of zio</a></div><div><a href="https://www.netlify.com"><img src="https://www.netlify.com/img/global/badges/netlify-color-accent.svg" alt="Deploys by Netlify"/></a></div></section><section class="copyright">Copyright © 2021 ZIO Maintainers</section></footer></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
                document.addEventListener('keyup', function(e) {
                  if (e.target !== document.body) {
                    return;
                  }
                  // keyCode for '/' (slash)
                  if (e.keyCode === 191) {
                    const search = document.getElementById('search_input_react');
                    search && search.focus();
                  }
                });
              </script><script>
              var search = docsearch({
                
                apiKey: '0c94b59071da7001757d08ab43d9e033',
                indexName: 'zio',
                inputSelector: '#search_input_react',
                algoliaOptions: {}
              });
            </script></body></html>