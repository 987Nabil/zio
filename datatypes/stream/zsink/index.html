<!doctype html>
<html class="docs-version-current" lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.6">
<link rel="search" type="application/opensearchdescription+xml" title="ZIO" href="/opensearch.xml">
<link rel="stylesheet" href="/css/prism/prism-material-dark.css"><title data-react-helmet="true">ZSink | ZIO</title><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><meta data-react-helmet="true" property="og:url" content="https://zio.dev/datatypes/stream/zsink"><meta data-react-helmet="true" name="docsearch:language" content="en"><meta data-react-helmet="true" name="docsearch:version" content="current"><meta data-react-helmet="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="ZSink | ZIO"><meta data-react-helmet="true" name="description" content="Introduction"><meta data-react-helmet="true" property="og:description" content="Introduction"><link data-react-helmet="true" rel="shortcut icon" href="/img/favicon.png"><link data-react-helmet="true" rel="canonical" href="https://zio.dev/datatypes/stream/zsink"><link data-react-helmet="true" rel="alternate" href="https://zio.dev/datatypes/stream/zsink" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://zio.dev/datatypes/stream/zsink" hreflang="x-default"><link data-react-helmet="true" rel="preconnect" href="https://BH4D9OD16A-dsn.algolia.net" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/styles.c1d60d2d.css">
<link rel="preload" href="/assets/js/runtime~main.9ec2f6f2.js" as="script">
<link rel="preload" href="/assets/js/main.aa9aa3fa.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div><a href="#" class="skipToContent_1oUP">Skip to main content</a></div><nav class="navbar navbar--fixed-top navbar--dark"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><img src="/img/navbar_brand.png" alt="ZIO" class="themedImage_1VuW themedImage--light_3UqQ navbar__logo"><img src="/img/navbar_brand.png" alt="ZIO" class="themedImage_1VuW themedImage--dark_hz6m navbar__logo"></a></div><div class="navbar__items navbar__items--right"><a class="navbar__item navbar__link" href="/overview/overview_index">Overview</a><a class="navbar__item navbar__link" href="/datatypes/index">Data Types</a><a class="navbar__item navbar__link" href="/usecases/usecases_index">Use Cases</a><a class="navbar__item navbar__link" href="/howto/index">How to</a><a class="navbar__item navbar__link" href="/resources/index">Resources</a><a class="navbar__item navbar__link" href="/about/index">About</a><div class="navbar__item dropdown dropdown--hoverable dropdown--right"><a class="navbar__link" href="/overview/overview_index">ZIO 2.x</a><ul class="dropdown__menu"><li><a aria-current="page" class="dropdown__link dropdown__link--active" href="/datatypes/stream/zsink">ZIO 2.x</a></li><li><a class="dropdown__link" href="/1.x/datatypes/stream/zsink">ZIO 1.x</a></li></ul></div><div class="react-toggle toggle_3Zt9 react-toggle--disabled"><div class="react-toggle-track" role="button" tabindex="-1"><div class="react-toggle-track-check"><span class="toggle_71bT">ðŸŒœ</span></div><div class="react-toggle-track-x"><span class="toggle_71bT">ðŸŒž</span></div><div class="react-toggle-thumb"></div></div><input type="checkbox" class="react-toggle-screenreader-only" aria-label="Switch between dark and light mode"></div><div class="searchBox_1Doo"><button type="button" class="DocSearch DocSearch-Button" aria-label="Search"><span class="DocSearch-Button-Container"><svg width="20" height="20" class="DocSearch-Search-Icon" viewBox="0 0 20 20"><path d="M14.386 14.386l4.0877 4.0877-4.0877-4.0877c-2.9418 2.9419-7.7115 2.9419-10.6533 0-2.9419-2.9418-2.9419-7.7115 0-10.6533 2.9418-2.9419 7.7115-2.9419 10.6533 0 2.9419 2.9418 2.9419 7.7115 0 10.6533z" stroke="currentColor" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"></path></svg><span class="DocSearch-Button-Placeholder">Search</span></span><span class="DocSearch-Button-Keys"></span></button></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper docs-wrapper docs-doc-page"><div class="docPage_31aa"><button class="clean-btn backToTopButton_35hR" type="button"><svg viewBox="0 0 24 24" width="28"><path d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z" fill="currentColor"></path></svg></button><aside class="docSidebarContainer_3Kbt"><div class="sidebar_15mo"><nav class="menu thin-scrollbar menu_Bmed menuWithAnnouncementBar_2WvA"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">Overview</a></li><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">Core Data Types</a></li><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">Contextual Types</a></li><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">Concurrency</a></li><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">Resource Safety</a></li><li class="theme-doc-sidebar-item-category menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#">Streaming</a><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/datatypes/stream/index">Introduction</a></li><li class="theme-doc-sidebar-item-category menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#" tabindex="0">Main Components</a><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#" tabindex="0">ZStream</a></li><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#" tabindex="0">ZTransducer</a></li><li class="theme-doc-sidebar-item-category menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#" tabindex="0">ZSink</a><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/datatypes/stream/zsink">ZSink</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/datatypes/stream/sink">Sink</a></li></ul></li></ul></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/datatypes/stream/subscription-ref">SubscriptionRef</a></li></ul></li><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">Metrics</a></li><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">Miscellaneous</a></li></ul></nav></div></aside><main class="docMainContainer_3ufF"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_3FnS"><div class="docItemContainer_33ec"><article><span class="theme-doc-version-badge badge badge--secondary">Version: ZIO 2.x</span><div class="tocCollapsible_1PrD theme-doc-toc-mobile tocMobile_3Hoh"><button type="button" class="clean-btn tocCollapsibleButton_2O1e">On this page</button></div><div class="theme-doc-markdown markdown"><header><h1>ZSink</h1></header><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_31ik" id="introduction"></a>Introduction<a class="hash-link" href="#introduction" title="Direct link to heading">#</a></h2><p>A <code>ZSink[R, E, I, L, Z]</code> is used to consume elements produced by a <code>ZStream</code>. You can think of a sink as a function that will consume a variable amount of <code>I</code> elements (could be 0, 1, or many!), might fail with an error of type <code>E</code>, and will eventually yield a value of type <code>Z</code> together with a remainder of type <code>L</code> as leftover.</p><p>To consume a stream using <code>ZSink</code> we can pass <code>ZSink</code> to the <code>ZStream#run</code> function:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly scala"><pre tabindex="0" class="prism-code language-scala codeBlock_23N8 thin-scrollbar"><code class="codeBlockLines_39YC"><span class="token-line"><span class="token plain">import zio._</span></span><span class="token-line"><span class="token plain">import zio.stream._</span></span><span class="token-line"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line"><span class="token plain">val stream = ZStream.fromIterable(1 to 1000)</span></span><span class="token-line"><span class="token plain">val sink   = ZSink.sum[Int]</span></span><span class="token-line"><span class="token plain">val sum    = stream.run(sink)</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_31ik" id="creating-sinks"></a>Creating sinks<a class="hash-link" href="#creating-sinks" title="Direct link to heading">#</a></h2><p>The <code>zio.stream</code> provides numerous kinds of sinks to use.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="common-constructors"></a>Common Constructors<a class="hash-link" href="#common-constructors" title="Direct link to heading">#</a></h3><p><strong>ZSink.head</strong> â€” It creates a sink containing the first element, returns <code>None</code> for empty streams:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly scala"><pre tabindex="0" class="prism-code language-scala codeBlock_23N8 thin-scrollbar"><code class="codeBlockLines_39YC"><span class="token-line"><span class="token plain">val sink: ZSink[Any, Nothing, Int, Int, Option[Int]] = ZSink.head[Int]</span></span><span class="token-line"><span class="token plain">val head: ZIO[Any, Nothing, Option[Int]]             = ZStream(1, 2, 3, 4).run(sink)</span></span><span class="token-line"><span class="token plain">// Result: Some(1)</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p><strong>ZSink.last</strong> â€” It consumes all elements of a stream and returns the last element of the stream:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly scala"><pre tabindex="0" class="prism-code language-scala codeBlock_23N8 thin-scrollbar"><code class="codeBlockLines_39YC"><span class="token-line"><span class="token plain">val sink: ZSink[Any, Nothing, Int, Nothing, Option[Int]] = ZSink.last[Int]</span></span><span class="token-line"><span class="token plain">val last: ZIO[Any, Nothing, Option[Int]]                 = ZStream(1, 2, 3, 4).run(sink)</span></span><span class="token-line"><span class="token plain">// Result: Some(4)</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p><strong>ZSink.count</strong> â€” A sink that consumes all elements of the stream and counts the number of elements fed to it:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly scala"><pre tabindex="0" class="prism-code language-scala codeBlock_23N8 thin-scrollbar"><code class="codeBlockLines_39YC"><span class="token-line"><span class="token plain">val sink : ZSink[Any, Nothing, Int, Nothing, Int] = ZSink.sum[Int]</span></span><span class="token-line"><span class="token plain">val count: ZIO[Any, Nothing, Int]                 = ZStream(1, 2, 3, 4, 5).run(sink)</span></span><span class="token-line"><span class="token plain">// Result: 5</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p><strong>ZSink.sum</strong> â€” A sink that consumes all elements of the stream and sums incoming numeric values:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly scala"><pre tabindex="0" class="prism-code language-scala codeBlock_23N8 thin-scrollbar"><code class="codeBlockLines_39YC"><span class="token-line"><span class="token plain">val sink : ZSink[Any, Nothing, Int, Nothing, Int] = ZSink.sum[Int]</span></span><span class="token-line"><span class="token plain">val sum: ZIO[Any, Nothing, Int]                 = ZStream(1, 2, 3, 4, 5).run(sink)</span></span><span class="token-line"><span class="token plain">// Result: 15</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p><strong>ZSink.take</strong> â€” A sink that takes the specified number of values and result in a <code>Chunk</code> data type:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly scala"><pre tabindex="0" class="prism-code language-scala codeBlock_23N8 thin-scrollbar"><code class="codeBlockLines_39YC"><span class="token-line"><span class="token plain">val sink  : ZSink[Any, Nothing, Int, Int, Chunk[Int]] = ZSink.take[Int](3)</span></span><span class="token-line"><span class="token plain">val stream: ZIO[Any, Nothing, Chunk[Int]]             = ZStream(1, 2, 3, 4, 5).run(sink)</span></span><span class="token-line"><span class="token plain">// Result: Chunk(1, 2, 3)</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p><strong>ZSink.drain</strong> â€” A sink that ignores its inputs:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly scala"><pre tabindex="0" class="prism-code language-scala codeBlock_23N8 thin-scrollbar"><code class="codeBlockLines_39YC"><span class="token-line"><span class="token plain">val drain: ZSink[Any, Nothing, Any, Nothing, Unit] = ZSink.drain</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p><strong>ZSink.timed</strong> â€” A sink that executes the stream and times its execution:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly scala"><pre tabindex="0" class="prism-code language-scala codeBlock_23N8 thin-scrollbar"><code class="codeBlockLines_39YC"><span class="token-line"><span class="token plain">val timed: ZSink[Has[Clock], Nothing, Any, Nothing, Duration] = ZSink.timed</span></span><span class="token-line"><span class="token plain">val stream: ZIO[Has[Clock], Nothing, Long] =</span></span><span class="token-line"><span class="token plain">  ZStream(1, 2, 3, 4, 5).fixed(2.seconds).run(timed).map(_.getSeconds)</span></span><span class="token-line"><span class="token plain">// Result: 10</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p><strong>ZSink.foreach</strong> â€” A sink that executes the provided effectful function for every element fed to it:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly scala"><pre tabindex="0" class="prism-code language-scala codeBlock_23N8 thin-scrollbar"><code class="codeBlockLines_39YC"><span class="token-line"><span class="token plain">val printer: ZSink[Has[Console], IOException, Int, Int, Unit] =</span></span><span class="token-line"><span class="token plain">  ZSink.foreach((i: Int) =&gt; printLine(i))</span></span><span class="token-line"><span class="token plain">val stream : ZIO[Has[Console], IOException, Unit]             =</span></span><span class="token-line"><span class="token plain">  ZStream(1, 2, 3, 4, 5).run(printer)</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="from-success-and-failure"></a>From Success and Failure<a class="hash-link" href="#from-success-and-failure" title="Direct link to heading">#</a></h3><p>Similar to the <code>ZStream</code> data type, we can create a <code>ZSink</code> using <code>fail</code> and <code>succeed</code> methods.</p><p>A sink that doesn&#x27;t consume any element of type <code>String</code> from its upstream and successes with a value of <code>Int</code> type:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly scala"><pre tabindex="0" class="prism-code language-scala codeBlock_23N8 thin-scrollbar"><code class="codeBlockLines_39YC"><span class="token-line"><span class="token plain">val succeed: ZSink[Any, Nothing, String, String, Int] = ZSink.succeed[String, Int](5)</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>A sink that doesn&#x27;t consume any element of type <code>Int</code> from its upstream and intentionally fails with a message of <code>String</code> type:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly scala"><pre tabindex="0" class="prism-code language-scala codeBlock_23N8 thin-scrollbar"><code class="codeBlockLines_39YC"><span class="token-line"><span class="token plain">val failed : ZSink[Any, String, Int, Int, Nothing] = ZSink.fail[String, Int](&quot;fail!&quot;)</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="collecting"></a>Collecting<a class="hash-link" href="#collecting" title="Direct link to heading">#</a></h3><p>To create a sink that collects all elements of a stream into a <code>Chunk[A]</code>, we can use <code>ZSink.collectAll</code>:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly scala"><pre tabindex="0" class="prism-code language-scala codeBlock_23N8 thin-scrollbar"><code class="codeBlockLines_39YC"><span class="token-line"><span class="token plain">val stream    : UStream[Int]    = UStream(1, 2, 3, 4, 5)</span></span><span class="token-line"><span class="token plain">val collection: UIO[Chunk[Int]] = stream.run(ZSink.collectAll[Int])</span></span><span class="token-line"><span class="token plain">// Output: Chunk(1, 2, 3, 4, 5)</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>We can collect all elements into a <code>Set</code>:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly scala"><pre tabindex="0" class="prism-code language-scala codeBlock_23N8 thin-scrollbar"><code class="codeBlockLines_39YC"><span class="token-line"><span class="token plain">val collectAllToSet: ZSink[Any, Nothing, Int, Nothing, Set[Int]] = ZSink.collectAllToSet[Int]</span></span><span class="token-line"><span class="token plain">val stream: ZIO[Any, Nothing, Set[Int]] = ZStream(1, 3, 2, 3, 1, 5, 1).run(collectAllToSet)</span></span><span class="token-line"><span class="token plain">// Output: Set(1, 3, 2, 5)</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>Or we can collect and merge them into a <code>Map[K, A]</code> using a merge function. In the following example, we use <code>(_:Int) % 3</code> to determine map keys and, we provide <code>_ + _</code> function to merge multiple elements with the same key:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly scala"><pre tabindex="0" class="prism-code language-scala codeBlock_23N8 thin-scrollbar"><code class="codeBlockLines_39YC"><span class="token-line"><span class="token plain">val collectAllToMap: ZSink[Any, Nothing, Int, Nothing, Map[Int, Int]] = ZSink.collectAllToMap((_: Int) % 3)(_ + _)</span></span><span class="token-line"><span class="token plain">val stream: ZIO[Any, Nothing, Map[Int, Int]] = ZStream(1, 3, 2, 3, 1, 5, 1).run(collectAllToMap)</span></span><span class="token-line"><span class="token plain">// Output: Map(1 -&gt; 3, 0 -&gt; 6, 2 -&gt; 7)</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="folding"></a>Folding<a class="hash-link" href="#folding" title="Direct link to heading">#</a></h3><p>Basic fold accumulation of received elements:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly scala"><pre tabindex="0" class="prism-code language-scala codeBlock_23N8 thin-scrollbar"><code class="codeBlockLines_39YC"><span class="token-line"><span class="token plain">ZSink.foldLeft[Int, Int](0)(_ + _)</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>A fold with short-circuiting has a termination predicate that determines the end of the folding process:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly scala"><pre tabindex="0" class="prism-code language-scala codeBlock_23N8 thin-scrollbar"><code class="codeBlockLines_39YC"><span class="token-line"><span class="token plain">ZStream.iterate(0)(_ + 1).run(</span></span><span class="token-line"><span class="token plain">  ZSink.fold(0)(sum =&gt; sum &lt;= 10)((acc, n: Int) =&gt; acc + n)</span></span><span class="token-line"><span class="token plain">)</span></span><span class="token-line"><span class="token plain">// Output: 15</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="from-effect"></a>From Effect<a class="hash-link" href="#from-effect" title="Direct link to heading">#</a></h3><p>The <code>ZSink.fromEffect</code> creates a single-value sink produced from an effect:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly scala"><pre tabindex="0" class="prism-code language-scala codeBlock_23N8 thin-scrollbar"><code class="codeBlockLines_39YC"><span class="token-line"><span class="token plain">val sink = ZSink.fromZIO(ZIO.succeed(1))</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="from-file"></a>From File<a class="hash-link" href="#from-file" title="Direct link to heading">#</a></h3><p>The <code>ZSink.fromFile</code> creates a file sink that consumes byte chunks and writes them to the specified file:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly scala"><pre tabindex="0" class="prism-code language-scala codeBlock_23N8 thin-scrollbar"><code class="codeBlockLines_39YC"><span class="token-line"><span class="token plain">def fileSink(path: Path): ZSink[Any, Throwable, String, Byte, Long] =</span></span><span class="token-line"><span class="token plain">  ZSink</span></span><span class="token-line"><span class="token plain">    .fromFile(path)</span></span><span class="token-line"><span class="token plain">    .contramapChunks[String](_.flatMap(_.getBytes))</span></span><span class="token-line"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line"><span class="token plain">val result = ZStream(&quot;Hello&quot;, &quot;ZIO&quot;, &quot;World!&quot;)</span></span><span class="token-line"><span class="token plain">  .intersperse(&quot;\n&quot;)</span></span><span class="token-line"><span class="token plain">  .run(fileSink(Paths.get(&quot;file.txt&quot;)))</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="from-outputstream"></a>From OutputStream<a class="hash-link" href="#from-outputstream" title="Direct link to heading">#</a></h3><p>The <code>ZSink.fromOutputStream</code> creates a sink that consumes byte chunks and write them to the <code>OutputStream</code>:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly scala"><pre tabindex="0" class="prism-code language-scala codeBlock_23N8 thin-scrollbar"><code class="codeBlockLines_39YC"><span class="token-line"><span class="token plain">ZStream(&quot;Application&quot;, &quot;Error&quot;, &quot;Logs&quot;)</span></span><span class="token-line"><span class="token plain">  .intersperse(&quot;\n&quot;)</span></span><span class="token-line"><span class="token plain">  .run(</span></span><span class="token-line"><span class="token plain">    ZSink</span></span><span class="token-line"><span class="token plain">      .fromOutputStream(java.lang.System.err)</span></span><span class="token-line"><span class="token plain">      .contramapChunks[String](_.flatMap(_.getBytes))</span></span><span class="token-line"><span class="token plain">  )</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="from-queue"></a>From Queue<a class="hash-link" href="#from-queue" title="Direct link to heading">#</a></h3><p>A queue has a finite or infinite buffer size, so they are useful in situations where we need to consume streams as fast as we can, and then do some batching operations on consumed messages. By using <code>ZSink.fromQueue</code> we can create a sink that is backed by a queue; it enqueues each element into the specified queue:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly scala"><pre tabindex="0" class="prism-code language-scala codeBlock_23N8 thin-scrollbar"><code class="codeBlockLines_39YC"><span class="token-line"><span class="token plain">val myApp: ZIO[Has[Console] with Has[Clock], IOException, Unit] =</span></span><span class="token-line"><span class="token plain">  for {</span></span><span class="token-line"><span class="token plain">    queue    &lt;- ZQueue.bounded[Int](32)</span></span><span class="token-line"><span class="token plain">    producer &lt;- ZStream</span></span><span class="token-line"><span class="token plain">      .iterate(1)(_ + 1)</span></span><span class="token-line"><span class="token plain">      .fixed(200.millis)</span></span><span class="token-line"><span class="token plain">      .run(ZSink.fromQueue(queue))</span></span><span class="token-line"><span class="token plain">      .fork</span></span><span class="token-line"><span class="token plain">    consumer &lt;- queue.take.flatMap(printLine(_)).forever</span></span><span class="token-line"><span class="token plain">    _        &lt;- producer.zip(consumer).join</span></span><span class="token-line"><span class="token plain">  } yield ()</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="from-hub"></a>From Hub<a class="hash-link" href="#from-hub" title="Direct link to heading">#</a></h3><p><code>Hub</code> is an asynchronous data type in which publisher can publish their messages to that and subscribers can subscribe to take messages from the <code>Hub</code>. The <code>ZSink.fromHub</code> takes a <code>ZHub</code> and returns a <code>ZSink</code> which publishes each element to that <code>ZHub</code>.</p><p>In the following example, the <code>sink</code> consumes elements of the <code>producer</code> stream and publishes them to the <code>hub</code>. We have two consumers that are subscribed to that hub and they are taking its elements forever:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly scala"><pre tabindex="0" class="prism-code language-scala codeBlock_23N8 thin-scrollbar"><code class="codeBlockLines_39YC"><span class="token-line"><span class="token plain">val myApp: ZIO[Has[Console] with Has[Clock], IOException, Unit] =</span></span><span class="token-line"><span class="token plain">  for {</span></span><span class="token-line"><span class="token plain">    promise &lt;- Promise.make[Nothing, Unit]</span></span><span class="token-line"><span class="token plain">    hub &lt;- ZHub.bounded[Int](1)</span></span><span class="token-line"><span class="token plain">    sink &lt;- ZIO.succeed(ZSink.fromHub(hub))</span></span><span class="token-line"><span class="token plain">    producer &lt;- ZStream.iterate(0)(_ + 1).fixed(1.seconds).run(sink).fork</span></span><span class="token-line"><span class="token plain">    consumers &lt;- hub.subscribe.zip(hub.subscribe).use { case (left, right) =&gt;</span></span><span class="token-line"><span class="token plain">      for {</span></span><span class="token-line"><span class="token plain">        _ &lt;- promise.succeed(())</span></span><span class="token-line"><span class="token plain">        f1 &lt;- left.take.flatMap(e =&gt; printLine(s&quot;Left Queue: $e&quot;)).forever.fork</span></span><span class="token-line"><span class="token plain">        f2 &lt;- right.take.flatMap(e =&gt; printLine(s&quot;Right Queue: $e&quot;)).forever.fork</span></span><span class="token-line"><span class="token plain">        _ &lt;- f1.zip(f2).join</span></span><span class="token-line"><span class="token plain">      } yield ()</span></span><span class="token-line"><span class="token plain">    }.fork</span></span><span class="token-line"><span class="token plain">    _ &lt;- promise.await</span></span><span class="token-line"><span class="token plain">    _ &lt;- producer.zip(consumers).join</span></span><span class="token-line"><span class="token plain">  } yield ()</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="from-push"></a>From Push<a class="hash-link" href="#from-push" title="Direct link to heading">#</a></h3><p>Before deepening into creating a <code>ZSink</code> using <code>Push</code> data-type, we need to learn more about the implementation details of <code>ZSink</code>. Note that this topic is for advanced users, and we do not require using <code>Push</code> data-type to create ZIO sinks, most of the time.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor anchor__h4 anchorWithStickyNavbar_31ik" id="zsinks-encoding"></a>ZSink&#x27;s Encoding<a class="hash-link" href="#zsinks-encoding" title="Direct link to heading">#</a></h4><p><code>ZSink</code> is a wrapper data-type around <em>managed</em> <code>Push</code>:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly scala"><pre tabindex="0" class="prism-code language-scala codeBlock_23N8 thin-scrollbar"><code class="codeBlockLines_39YC"><span class="token-line"><span class="token plain">abstract class ZSink[-R, +E, -I, +L, +Z] private (</span></span><span class="token-line"><span class="token plain">    val push: ZManaged[R, Nothing, ZSink.Push[R, E, I, L, Z]]</span></span><span class="token-line"><span class="token plain">) </span></span><span class="token-line"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line"><span class="token plain">object ZSink {</span></span><span class="token-line"><span class="token plain">  type Push[-R, +E, -I, +L, +Z] =</span></span><span class="token-line"><span class="token plain">    Option[Chunk[I]] =&gt; ZIO[R, (Either[E, Z], Chunk[L]), Unit]</span></span><span class="token-line"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p><code>Push</code> is a function from <code>Option[Chunk[I]]</code> to <code>ZIO[R, (Either[E, Z], Chunk[L]), Unit]</code>. We can create four different data-types using its smart constructors:</p><ol><li><strong>Push.more</strong> â€” Using this constructor we create a <code>Push</code> data-type that requires more values to consume (<code>Option[Chunk[I]] =&gt; UIO[Unit]</code>):</li></ol><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly scala"><pre tabindex="0" class="prism-code language-scala codeBlock_23N8 thin-scrollbar"><code class="codeBlockLines_39YC"><span class="token-line"><span class="token plain">object Push {</span></span><span class="token-line"><span class="token plain">  val more: ZIO[Any, Nothing, Unit] = UIO.unit</span></span><span class="token-line"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><ol start="2"><li><strong>Push.emit</strong> â€” By providing <code>z</code> (as an <em>end</em> value) and <code>leftover</code> arguments to this constructor we can create a <code>Push</code> data-type describing a sink that ends with <code>z</code> value and emits its leftovers (<code>Option[Chunk[I]] =&gt; IO[(Right[Nothing, Z], Chunk[I]), Nothing]</code>):</li></ol><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly scala"><pre tabindex="0" class="prism-code language-scala codeBlock_23N8 thin-scrollbar"><code class="codeBlockLines_39YC"><span class="token-line"><span class="token plain">object Push {</span></span><span class="token-line"><span class="token plain">def emit[I, Z](</span></span><span class="token-line"><span class="token plain">    z: Z,</span></span><span class="token-line"><span class="token plain">    leftover: Chunk[I]</span></span><span class="token-line"><span class="token plain">): IO[(Right[Nothing, Z], Chunk[I]), Nothing] =</span></span><span class="token-line"><span class="token plain">  IO.fail((Right(z), leftover))</span></span><span class="token-line"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><ol start="3"><li><strong>Push.fail</strong> â€” By providing an error message and leftover to this constructor, we can create a <code>Push</code> data-type describing a sink that fails with <code>e</code> and emits the leftover (<code>Option[Chunk[I]] =&gt; IO[(Left[E, Nothing], Chunk[I]), Nothing]</code>):</li></ol><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly scala"><pre tabindex="0" class="prism-code language-scala codeBlock_23N8 thin-scrollbar"><code class="codeBlockLines_39YC"><span class="token-line"><span class="token plain">def fail[I, E](</span></span><span class="token-line"><span class="token plain">    e: E,</span></span><span class="token-line"><span class="token plain">    leftover: Chunk[I]</span></span><span class="token-line"><span class="token plain">): IO[(Left[E, Nothing], Chunk[I]), Nothing] = </span></span><span class="token-line"><span class="token plain">  IO.fail((Left(e), leftover))</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><ol start="4"><li><strong>Push.failCause</strong> â€” By providing a <code>Cause</code> we can create a <code>Push</code> data-type describing a sink that halts the process of consuming elements (<code>Option[Chunk[I]] =&gt; ZIO[Any, (Left[E, Nothing], Chunk[Nothing]), Nothing]</code>):</li></ol><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly scala"><pre tabindex="0" class="prism-code language-scala codeBlock_23N8 thin-scrollbar"><code class="codeBlockLines_39YC"><span class="token-line"><span class="token plain">def failCause[E](</span></span><span class="token-line"><span class="token plain">    c: Cause[E]</span></span><span class="token-line"><span class="token plain">): ZIO[Any, (Left[E, Nothing], Chunk[Nothing]), Nothing] =</span></span><span class="token-line"><span class="token plain">  IO.failCause(c).mapError(e =&gt; (Left(e), Chunk.empty))</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>Now, we are ready to see how the existing <code>ZSink.head</code> sink is implemented using <code>Push</code> data-type:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly scala"><pre tabindex="0" class="prism-code language-scala codeBlock_23N8 thin-scrollbar"><code class="codeBlockLines_39YC"><span class="token-line"><span class="token plain">def head[I]: ZSink[Any, Nothing, I, I, Option[I]] =</span></span><span class="token-line"><span class="token plain">  ZSink[Any, Nothing, I, I, Option[I]](ZManaged.succeed({</span></span><span class="token-line"><span class="token plain">    case Some(ch) =&gt;</span></span><span class="token-line"><span class="token plain">      if (ch.isEmpty) { // If the chunk is empty, we require more elements</span></span><span class="token-line"><span class="token plain">        Push.more</span></span><span class="token-line"><span class="token plain">      } else {</span></span><span class="token-line"><span class="token plain">        Push.emit(Some(ch.head), ch.drop(1))</span></span><span class="token-line"><span class="token plain">      }</span></span><span class="token-line"><span class="token plain">    case None =&gt; Push.emit(None, Chunk.empty)</span></span><span class="token-line"><span class="token plain">  }))</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h4><a aria-hidden="true" tabindex="-1" class="anchor anchor__h4 anchorWithStickyNavbar_31ik" id="creating-zsink-using-push"></a>Creating ZSink using Push<a class="hash-link" href="#creating-zsink-using-push" title="Direct link to heading">#</a></h4><p>To create a ZSink using <code>Push</code> data-type, we should use <code>ZSink.fromPush</code> constructor. This constructor is implemented as below:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly scala"><pre tabindex="0" class="prism-code language-scala codeBlock_23N8 thin-scrollbar"><code class="codeBlockLines_39YC"><span class="token-line"><span class="token plain">object ZSink {</span></span><span class="token-line"><span class="token plain">  def fromPush[R, E, I, L, Z](sink: Push[R, E, I, L, Z]): ZSink[R, E, I, L, Z] =</span></span><span class="token-line"><span class="token plain">    ZSink(Managed.succeed(sink))</span></span><span class="token-line"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>So nothing special, it just creates us a new <code>ZSink</code> containing a managed push. </p><p>Let&#x27;s rewrite <code>ZSink.succeed</code> and <code>ZSink.fail</code> â€” the two existing ZIO sinks â€” using <code>fromPush</code>:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly scala"><pre tabindex="0" class="prism-code language-scala codeBlock_23N8 thin-scrollbar"><code class="codeBlockLines_39YC"><span class="token-line"><span class="token plain">def succeed[I, Z](z: =&gt; Z): ZSink[Any, Nothing, I, I, Z] =</span></span><span class="token-line"><span class="token plain">  ZSink.fromPush[Any, Nothing, I, I, Z] { c =&gt;</span></span><span class="token-line"><span class="token plain">    val leftover = c.fold[Chunk[I]](Chunk.empty)(identity)</span></span><span class="token-line"><span class="token plain">    Push.emit(z, leftover)</span></span><span class="token-line"><span class="token plain">  }</span></span><span class="token-line"><span class="token plain">  </span></span><span class="token-line"><span class="token plain">def fail[E, I](e: =&gt; E): ZSink[Any, E, I, I, Nothing] =</span></span><span class="token-line"><span class="token plain">  ZSink.fromPush[Any, E, I, I, Nothing] { c =&gt;</span></span><span class="token-line"><span class="token plain">    val leftover = c.fold[Chunk[I]](Chunk.empty)(identity)</span></span><span class="token-line"><span class="token plain">    Push.fail(e, leftover)</span></span><span class="token-line"><span class="token plain">  }</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_31ik" id="operations"></a>Operations<a class="hash-link" href="#operations" title="Direct link to heading">#</a></h2><p>Having created the sink, we can transform it with provided operations.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="contramap"></a>contramap<a class="hash-link" href="#contramap" title="Direct link to heading">#</a></h3><p>Contramap is a simple combinator to change the domain of an existing function. While <em>map</em> changes the co-domain of a function, the <em>contramap</em> changes the domain of a function. So the <em>contramap</em> takes a function and maps over its input.</p><p>This is useful when we have a fixed output, and our existing function cannot consume those outputs. So we can use <em>contramap</em> to create a new function that can consume that fixed output. Assume we have a <code>ZSink.sum</code> that sums incoming numeric values, but we have a <code>ZStream</code> of <code>String</code> values. We can convert the <code>ZSink.sum</code> to a sink that can consume <code>String</code> values;</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly scala"><pre tabindex="0" class="prism-code language-scala codeBlock_23N8 thin-scrollbar"><code class="codeBlockLines_39YC"><span class="token-line"><span class="token plain">val numericSum: ZSink[Any, Nothing, Int, Nothing, Int]    = </span></span><span class="token-line"><span class="token plain">  ZSink.sum[Int]</span></span><span class="token-line"><span class="token plain">val stringSum : ZSink[Any, Nothing, String, Nothing, Int] = </span></span><span class="token-line"><span class="token plain">  numericSum.contramap((x: String) =&gt; x.toInt)</span></span><span class="token-line"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line"><span class="token plain">val sum: ZIO[Any, Nothing, Int] =</span></span><span class="token-line"><span class="token plain">  ZStream(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;).run(stringSum)</span></span><span class="token-line"><span class="token plain">// Output: 15</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="dimap"></a>dimap<a class="hash-link" href="#dimap" title="Direct link to heading">#</a></h3><p>A <code>dimap</code> is an extended <code>contramap</code> that additionally transforms sink&#x27;s output:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly scala"><pre tabindex="0" class="prism-code language-scala codeBlock_23N8 thin-scrollbar"><code class="codeBlockLines_39YC"><span class="token-line"><span class="token plain">// Convert its input to integers, do the computation and then convert them back to a string</span></span><span class="token-line"><span class="token plain">val sumSink: ZSink[Any, Nothing, String, Nothing, String] =</span></span><span class="token-line"><span class="token plain">  numericSum.dimap[String, String](_.toInt, _.toString)</span></span><span class="token-line"><span class="token plain">  </span></span><span class="token-line"><span class="token plain">val sum: ZIO[Any, Nothing, String] =</span></span><span class="token-line"><span class="token plain">  ZStream(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;).run(sumSink)</span></span><span class="token-line"><span class="token plain">// Output: 15</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_31ik" id="concurrency-and-parallelism"></a>Concurrency and Parallelism<a class="hash-link" href="#concurrency-and-parallelism" title="Direct link to heading">#</a></h2><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="parallel-zipping"></a>Parallel Zipping<a class="hash-link" href="#parallel-zipping" title="Direct link to heading">#</a></h3><p>Like <code>ZStream</code>, two <code>ZSink</code> can be zipped together. Both of them will be run in parallel, and their results will be combined in a tuple:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly scala"><pre tabindex="0" class="prism-code language-scala codeBlock_23N8 thin-scrollbar"><code class="codeBlockLines_39YC"><span class="token-line"><span class="token plain">val kafkaSink: ZSink[Any, Throwable, Record, Record, Unit] =</span></span><span class="token-line"><span class="token plain">  ZSink.foreach[Any, Throwable, Record](record =&gt; ZIO.attempt(???))</span></span><span class="token-line"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line"><span class="token plain">val pulsarSink: ZSink[Any, Throwable, Record, Record, Unit] =</span></span><span class="token-line"><span class="token plain">  ZSink.foreach[Any, Throwable, Record](record =&gt; ZIO.attempt(???))</span></span><span class="token-line"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line"><span class="token plain">val stream: ZSink[Any, Throwable, Record, Record, Unit] =</span></span><span class="token-line"><span class="token plain">  kafkaSink zipPar pulsarSink </span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="racing"></a>Racing<a class="hash-link" href="#racing" title="Direct link to heading">#</a></h3><p>We are able to <code>race</code> multiple sinks, they will run in parallel, and the one that wins will provide the result of our program:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly scala"><pre tabindex="0" class="prism-code language-scala codeBlock_23N8 thin-scrollbar"><code class="codeBlockLines_39YC"><span class="token-line"><span class="token plain">val stream: ZSink[Any, Throwable, Record, Record, Unit] =</span></span><span class="token-line"><span class="token plain">  kafkaSink race pulsarSink </span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>To determine which one succeeded, we should use the <code>ZSink#raceBoth</code> combinator, it returns an <code>Either</code> result.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_31ik" id="leftovers"></a>Leftovers<a class="hash-link" href="#leftovers" title="Direct link to heading">#</a></h2><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="exposing-leftovers"></a>Exposing Leftovers<a class="hash-link" href="#exposing-leftovers" title="Direct link to heading">#</a></h3><p>A sink consumes a variable amount of <code>I</code> elements (zero or more) from the upstream. If the upstream is finite, we can expose leftover values by calling <code>ZSink#exposeLeftOver</code>. It returns a tuple that contains the result of the previous sink and its leftovers:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly scala"><pre tabindex="0" class="prism-code language-scala codeBlock_23N8 thin-scrollbar"><code class="codeBlockLines_39YC"><span class="token-line"><span class="token plain">val s1: ZIO[Any, Nothing, (Chunk[Int], Chunk[Int])] =</span></span><span class="token-line"><span class="token plain">  ZStream(1, 2, 3, 4, 5).run(</span></span><span class="token-line"><span class="token plain">    ZSink.take(3).exposeLeftover</span></span><span class="token-line"><span class="token plain">  )</span></span><span class="token-line"><span class="token plain">// Output: (Chunk(1, 2, 3), Chunk(4, 5))</span></span><span class="token-line"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line"><span class="token plain">val s2: ZIO[Any, Nothing, (Option[Int], Chunk[Int])] =</span></span><span class="token-line"><span class="token plain">  ZStream(1, 2, 3, 4, 5).run(</span></span><span class="token-line"><span class="token plain">    ZSink.head[Int].exposeLeftover</span></span><span class="token-line"><span class="token plain">  )</span></span><span class="token-line"><span class="token plain">// Output: (Some(1), Chunk(2, 3, 4, 5))</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="dropping-leftovers"></a>Dropping Leftovers<a class="hash-link" href="#dropping-leftovers" title="Direct link to heading">#</a></h3><p>If we don&#x27;t need leftovers, we can drop them by using <code>ZSink#dropLeftover</code>:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly scala"><pre tabindex="0" class="prism-code language-scala codeBlock_23N8 thin-scrollbar"><code class="codeBlockLines_39YC"><span class="token-line"><span class="token plain">ZSink.take[Int](3).dropLeftover</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div></div></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/datatypes/stream/transducer"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">Â« Transducer</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/datatypes/stream/sink"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">Sink Â»</div></a></div></nav></div></div><div class="col col--3"><div class="tableOfContents_35-E thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#introduction" class="table-of-contents__link">Introduction</a></li><li><a href="#creating-sinks" class="table-of-contents__link">Creating sinks</a><ul><li><a href="#common-constructors" class="table-of-contents__link">Common Constructors</a></li><li><a href="#from-success-and-failure" class="table-of-contents__link">From Success and Failure</a></li><li><a href="#collecting" class="table-of-contents__link">Collecting</a></li><li><a href="#folding" class="table-of-contents__link">Folding</a></li><li><a href="#from-effect" class="table-of-contents__link">From Effect</a></li><li><a href="#from-file" class="table-of-contents__link">From File</a></li><li><a href="#from-outputstream" class="table-of-contents__link">From OutputStream</a></li><li><a href="#from-queue" class="table-of-contents__link">From Queue</a></li><li><a href="#from-hub" class="table-of-contents__link">From Hub</a></li><li><a href="#from-push" class="table-of-contents__link">From Push</a></li></ul></li><li><a href="#operations" class="table-of-contents__link">Operations</a><ul><li><a href="#contramap" class="table-of-contents__link">contramap</a></li><li><a href="#dimap" class="table-of-contents__link">dimap</a></li></ul></li><li><a href="#concurrency-and-parallelism" class="table-of-contents__link">Concurrency and Parallelism</a><ul><li><a href="#parallel-zipping" class="table-of-contents__link">Parallel Zipping</a></li><li><a href="#racing" class="table-of-contents__link">Racing</a></li></ul></li><li><a href="#leftovers" class="table-of-contents__link">Leftovers</a><ul><li><a href="#exposing-leftovers" class="table-of-contents__link">Exposing Leftovers</a></li><li><a href="#dropping-leftovers" class="table-of-contents__link">Dropping Leftovers</a></li></ul></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container"><div class="row footer__links"><div class="col footer__col"><ul class="footer__items"><li class="footer__item">
                <img src="/img/navbar_brand.png" alt="zio">
            </li></ul></div><div class="col footer__col"><div class="footer__title">Github</div><ul class="footer__items"><li class="footer__item">
              <a href="https://github.com/zio/zio">
                <img src="https://img.shields.io/github/stars/zio/zio?style=social" alt="github">
              </a>
            </li></ul></div><div class="col footer__col"><div class="footer__title">Chat with us on Discord</div><ul class="footer__items"><li class="footer__item">
                <a href="https://discord.gg/2ccFBr4">
                  <img src="https://img.shields.io/discord/629491597070827530?logo=discord&style=social" alt="discord">
                </a>
              </li></ul></div><div class="col footer__col"><div class="footer__title">Follow us on Twitter</div><ul class="footer__items"><li class="footer__item">
                <a href="https://twitter.com/zioscala">
                  <img src="https://img.shields.io/twitter/follow/zioscala?label=Follow&style=social" alt="twitter">
                </a>
              </li></ul></div><div class="col footer__col"><div class="footer__title">Additional resources</div><ul class="footer__items"><li class="footer__item"><a href="/api/zio/" target="_blank">Latest Scaladoc of ZIO</a></li><li class="footer__item"><a href="/api-1.x/zio/" target="_blank">Scaladoc of ZIO-1.x</a></li><li class="footer__item"><a href="https://javadoc.io/doc/dev.zio/" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>Scaladoc on javadoc.io<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></div><div class="col footer__col"><ul class="footer__items"><li class="footer__item">
                <a href="https://www.netlify.com">
                  <img src="https://www.netlify.com/img/global/badges/netlify-color-accent.svg" alt="Deploys by Netlify">
                </a>
              </li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright Â© 2021 ZIO Maintainers - Built with <a href="https://v2.docusaurus.io/">Docusaurus v2</a></div></div></div></footer></div>
<script src="/assets/js/runtime~main.9ec2f6f2.js"></script>
<script src="/assets/js/main.aa9aa3fa.js"></script>
</body>
</html>