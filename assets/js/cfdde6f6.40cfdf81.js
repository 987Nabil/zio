"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[3681],{3905:function(e,n,t){t.d(n,{Zo:function(){return s},kt:function(){return k}});var r=t(7294);function o(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function a(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){o(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,r,o=function(e,n){if(null==e)return{};var t,r,o={},i=Object.keys(e);for(r=0;r<i.length;r++)t=i[r],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)t=i[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var c=r.createContext({}),p=function(e){var n=r.useContext(c),t=n;return e&&(t="function"==typeof e?e(n):a(a({},n),e)),t},s=function(e){var n=p(e.components);return r.createElement(c.Provider,{value:n},e.children)},u={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},d=r.forwardRef((function(e,n){var t=e.components,o=e.mdxType,i=e.originalType,c=e.parentName,s=l(e,["components","mdxType","originalType","parentName"]),d=p(t),k=o,g=d["".concat(c,".").concat(k)]||d[k]||u[k]||i;return t?r.createElement(g,a(a({ref:n},s),{},{components:t})):r.createElement(g,a({ref:n},s))}));function k(e,n){var t=arguments,o=n&&n.mdxType;if("string"==typeof e||o){var i=t.length,a=new Array(i);a[0]=d;var l={};for(var c in n)hasOwnProperty.call(n,c)&&(l[c]=n[c]);l.originalType=e,l.mdxType="string"==typeof e?e:o,a[1]=l;for(var p=2;p<i;p++)a[p]=t[p];return r.createElement.apply(null,a)}return r.createElement.apply(null,t)}d.displayName="MDXCreateElement"},9678:function(e,n,t){t.r(n),t.d(n,{frontMatter:function(){return l},contentTitle:function(){return c},metadata:function(){return p},toc:function(){return s},default:function(){return d}});var r=t(7462),o=t(3366),i=(t(7294),t(3905)),a=["components"],l={id:"blocking",title:"Blocking"},c=void 0,p={unversionedId:"services/blocking",id:"services/blocking",isDocsHomePage:!1,title:"Blocking",description:"Introduction",source:"@site/docs/services/blocking.md",sourceDirName:"services",slug:"/services/blocking",permalink:"/services/blocking",tags:[],version:"current",frontMatter:{id:"blocking",title:"Blocking"},sidebar:"services-sidebar",previous:{title:"Random",permalink:"/services/random"},next:{title:"System",permalink:"/services/system"}},s=[{value:"Introduction",id:"introduction",children:[]},{value:"Creating Blocking Effects",id:"creating-blocking-effects",children:[]},{value:"Interruption of Blocking Operations",id:"interruption-of-blocking-operations",children:[]},{value:"Cancellation of Blocking Operation",id:"cancellation-of-blocking-operation",children:[]}],u={toc:s};function d(e){var n=e.components,t=(0,o.Z)(e,a);return(0,i.kt)("wrapper",(0,r.Z)({},u,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("h2",{id:"introduction"},"Introduction"),(0,i.kt)("p",null,"ZIO provides access to a thread pool that can be used for performing\nblocking operations, such as thread sleeps, synchronous socket/file reads, and so forth. "),(0,i.kt)("p",null,"By default, ZIO is asynchronous and all effects will be executed on a default primary thread pool which is optimized for asynchronous operations. As ZIO uses a fiber-based concurrency model, if we run ",(0,i.kt)("strong",{parentName:"p"},"Blocking I/O")," or ",(0,i.kt)("strong",{parentName:"p"},"CPU Work")," workloads on a primary thread pool, they are going to monopolize all threads of ",(0,i.kt)("strong",{parentName:"p"},"primary thread pool"),"."),(0,i.kt)("p",null,"In the following example, we create 20 blocking tasks to run parallel on the primary async thread pool. Assume we have a machine with an 8 CPU core, so the ZIO creates a thread pool of size 16 (2 * 8). If we run this program, all of our threads got stuck, and the remaining 4 blocking tasks (20 - 16) haven't any chance to run on our thread pool:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\nimport zio.Console._\ndef blockingTask(n: Int): URIO[Has[Console], Unit] =\n  printLine(s"running blocking task number $n").orDie *>\n    ZIO.succeed(Thread.sleep(3000)) *>\n    blockingTask(n)\n\nval program = ZIO.foreachPar((1 to 100).toArray)(blockingTask)\n')),(0,i.kt)("h2",{id:"creating-blocking-effects"},"Creating Blocking Effects"),(0,i.kt)("p",null,"ZIO has a separate ",(0,i.kt)("strong",{parentName:"p"},"blocking thread pool")," specially designed for ",(0,i.kt)("strong",{parentName:"p"},"Blocking I/O")," and, also ",(0,i.kt)("strong",{parentName:"p"},"CPU Work")," workloads. We should run blocking workloads on this thread pool to prevent interfering with the primary thread pool."),(0,i.kt)("p",null,"The contract is that the thread pool will accept unlimited tasks (up to the available memory)\nand continuously create new threads as necessary."),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"blocking")," operator takes a ZIO effect and return another effect that is going to run on a blocking thread pool:"),(0,i.kt)("p",null,"Also, we can directly import a synchronous effect that does blocking IO into ZIO effect by using ",(0,i.kt)("inlineCode",{parentName:"p"},"attemptBlocking"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'def blockingTask(n: Int) = ZIO.attemptBlocking {\n  do {\n    println(s"Running blocking task number $n on dedicated blocking thread pool")\n    Thread.sleep(3000) \n  } while (true)\n}\n')),(0,i.kt)("h2",{id:"interruption-of-blocking-operations"},"Interruption of Blocking Operations"),(0,i.kt)("p",null,"By default, when we convert a blocking operation into the ZIO effects using ",(0,i.kt)("inlineCode",{parentName:"p"},"attemptBlocking"),", there is no guarantee that if that effect is interrupted the underlying effect will be interrupted."),(0,i.kt)("p",null,"Let's create a blocking effect from an endless loop:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'for {\n  _ <- printLine("Starting a blocking operation")\n  fiber <- ZIO.attemptBlocking {\n    while (true) {\n      Thread.sleep(1000)\n      println("Doing some blocking operation")\n    }\n  }.ensuring(\n    printLine("End of a blocking operation").orDie\n  ).fork\n  _ <- fiber.interrupt.schedule(\n    Schedule.delayed(\n      Schedule.duration(1.seconds)\n    )\n  )\n} yield ()\n')),(0,i.kt)("p",null,"When we interrupt this loop after one second, it will not interrupted. It will only stop when the entire JVM stops. So the ",(0,i.kt)("inlineCode",{parentName:"p"},"attemptBlocking")," doesn't translate the ZIO interruption into thread interruption (",(0,i.kt)("inlineCode",{parentName:"p"},"Thread.interrupt"),"). "),(0,i.kt)("p",null,"Instead, we should use ",(0,i.kt)("inlineCode",{parentName:"p"},"attemptBlockingInterrupt")," to create interruptible blocking effects:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'for {\n  _ <- printLine("Starting a blocking operation")\n  fiber <- ZIO.attemptBlockingInterrupt {\n    while(true) {\n      Thread.sleep(1000)\n      println("Doing some blocking operation")\n    }\n  }.ensuring(\n     printLine("End of the blocking operation").orDie\n   ).fork\n  _ <- fiber.interrupt.schedule(\n    Schedule.delayed(\n      Schedule.duration(3.seconds)\n    )\n  )\n} yield ()\n')),(0,i.kt)("p",null,"Notes:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"If we are converting a blocking I/O to the ZIO effect, it would be better to use ",(0,i.kt)("inlineCode",{parentName:"p"},"attemptBlockingIO")," which refines the error type to the ",(0,i.kt)("inlineCode",{parentName:"p"},"java.io.IOException"),".")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"The ",(0,i.kt)("inlineCode",{parentName:"p"},"attemptBlockingInterrupt")," method adds significant overhead. So for performance-sensitive applications, it is better to handle interruptions manually using ",(0,i.kt)("inlineCode",{parentName:"p"},"attemptBlockingCancelable"),"."))),(0,i.kt)("h2",{id:"cancellation-of-blocking-operation"},"Cancellation of Blocking Operation"),(0,i.kt)("p",null,"Some blocking operations do not respect ",(0,i.kt)("inlineCode",{parentName:"p"},"Thread#interrupt")," by swallowing ",(0,i.kt)("inlineCode",{parentName:"p"},"InterruptedException"),". So, they will not be interrupted via ",(0,i.kt)("inlineCode",{parentName:"p"},"attemptBlockingInterrupt"),". Instead, they may provide us an API to signal them to ",(0,i.kt)("em",{parentName:"p"},"cancel")," their operation."),(0,i.kt)("p",null,"The following ",(0,i.kt)("inlineCode",{parentName:"p"},"BlockingService")," will not be interrupted in case of ",(0,i.kt)("inlineCode",{parentName:"p"},"Thread#interrupt")," call, but it checks the ",(0,i.kt)("inlineCode",{parentName:"p"},"released")," flag constantly. If this flag becomes true, the blocking service will finish its job:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'import java.util.concurrent.atomic.AtomicReference\nfinal case class BlockingService() {\n  private val released = new AtomicReference(false)\n\n  def start(): Unit = {\n    while (!released.get()) {\n      println("Doing some blocking operation")\n      try Thread.sleep(1000)\n      catch {\n        case _: InterruptedException => () // Swallowing InterruptedException\n      }\n    }\n    println("Blocking operation closed.")\n  }\n\n  def close(): Unit = {\n    println("Releasing resources and ready to be closed.")\n    released.getAndSet(true)\n  }\n}\n')),(0,i.kt)("p",null,"So, to translate ZIO interruption into cancellation of these types of blocking operations we should use ",(0,i.kt)("inlineCode",{parentName:"p"},"attemptBlockingCancelable"),". This method takes a ",(0,i.kt)("inlineCode",{parentName:"p"},"cancel")," effect which responsible to signal the blocking code to close itself when ZIO interruption occurs:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"val myApp =\n  for {\n    service <- ZIO.attempt(BlockingService())\n    fiber   <- ZIO.attemptBlockingCancelable(\n      effect = service.start()\n    )(\n      cancel = UIO.succeed(service.close())\n    ).fork\n    _       <- fiber.interrupt.schedule(\n      Schedule.delayed(\n        Schedule.duration(3.seconds)\n      )\n    )\n  } yield ()\n")),(0,i.kt)("p",null,"Here is another example of the cancelation of a blocking operation. When we ",(0,i.kt)("inlineCode",{parentName:"p"},"accept")," a server socket, this blocking operation will never interrupted until we close that using ",(0,i.kt)("inlineCode",{parentName:"p"},"ServerSocket#close")," method:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"import java.net.{Socket, ServerSocket}\ndef accept(ss: ServerSocket): Task[Socket] =\n  ZIO.attemptBlockingCancelable(ss.accept())(UIO.succeed(ss.close()))\n")))}d.isMDXComponent=!0}}]);